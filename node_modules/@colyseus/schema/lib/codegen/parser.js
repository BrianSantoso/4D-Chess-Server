"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFiles = void 0;
var ts = require("typescript");
var path = require("path");
var fs_1 = require("fs");
var types_1 = require("./types");
var currentStructure;
var currentProperty;
var globalContext;
function defineProperty(property, initializer) {
    if (ts.isIdentifier(initializer)) {
        property.type = "ref";
        property.childType = initializer.text;
    }
    else if (initializer.kind == ts.SyntaxKind.ObjectLiteralExpression) {
        property.type = initializer.properties[0].name.text;
        property.childType = initializer.properties[0].initializer.text;
    }
    else if (initializer.kind == ts.SyntaxKind.ArrayLiteralExpression) {
        property.type = "array";
        property.childType = initializer.elements[0].text;
    }
    else {
        property.type = initializer.text;
    }
}
function inspectNode(node, context, decoratorName) {
    var _a, _b, _c, _d, _e;
    switch (node.kind) {
        case ts.SyntaxKind.ImportClause:
            var specifier = node.parent.moduleSpecifier;
            if (specifier && specifier.text.startsWith('.')) {
                var currentDir = path.dirname(node.getSourceFile().fileName);
                var pathToImport = path.resolve(currentDir, specifier.text);
                parseFiles([pathToImport], decoratorName, globalContext);
            }
            break;
        case ts.SyntaxKind.ClassDeclaration:
            currentStructure = new types_1.Class();
            var heritageClauses = node.heritageClauses;
            if (heritageClauses && heritageClauses.length > 0) {
                currentStructure.extends = heritageClauses[0].types[0].expression.getText();
            }
            context.addStructure(currentStructure);
            break;
        case ts.SyntaxKind.InterfaceDeclaration:
            //
            // Only generate Interfaces if it has "Message" on its name.
            // Example: MyMessage
            //
            var interfaceName = node.name.escapedText.toString();
            if (interfaceName.indexOf("Message") !== -1) {
                currentStructure = new types_1.Interface();
                currentStructure.name = interfaceName;
                context.addStructure(currentStructure);
            }
            break;
        case ts.SyntaxKind.ExtendsKeyword:
            // console.log(node.getText());
            break;
        case ts.SyntaxKind.PropertySignature:
            if (currentStructure instanceof types_1.Interface) {
                var interfaceDeclaration = node.parent;
                if (currentStructure.name !== interfaceDeclaration.name.escapedText.toString()) {
                    // skip if property if for a another interface than the one we're interested in.
                    break;
                }
                // define a property of an interface
                var property = new types_1.Property();
                property.name = node.name.escapedText.toString();
                property.type = node.type.getText();
                currentStructure.addProperty(property);
            }
            break;
        case ts.SyntaxKind.Identifier:
            if (node.getText() === "deprecated" &&
                node.parent.kind !== ts.SyntaxKind.ImportSpecifier) {
                currentProperty = new types_1.Property();
                currentProperty.deprecated = true;
                break;
            }
            if (node.getText() === decoratorName) {
                var prop = (_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.parent;
                var propDecorator = prop === null || prop === void 0 ? void 0 : prop.decorators;
                var hasExpression = (_c = prop === null || prop === void 0 ? void 0 : prop.expression) === null || _c === void 0 ? void 0 : _c.arguments;
                /**
                 * neither a `@type()` decorator or `type()` call. skip.
                 */
                if (!propDecorator && !hasExpression) {
                    break;
                }
                // using as decorator
                if (propDecorator) {
                    /**
                     * Calling `@type()` as decorator
                     */
                    var typeDecorator = propDecorator.find((function (decorator) {
                        return decorator.expression.expression.escapedText === decoratorName;
                    })).expression;
                    var property = currentProperty || new types_1.Property();
                    property.name = prop.name.escapedText;
                    currentStructure.addProperty(property);
                    var typeArgument = typeDecorator.arguments[0];
                    defineProperty(property, typeArgument);
                }
                else if (((_d = prop.expression.arguments) === null || _d === void 0 ? void 0 : _d[1]) && ((_e = prop.expression.expression.arguments) === null || _e === void 0 ? void 0 : _e[0])) {
                    /**
                     * Calling `type()` as a regular method
                     */
                    var property = currentProperty || new types_1.Property();
                    property.name = prop.expression.arguments[1].text;
                    currentStructure.addProperty(property);
                    var typeArgument = prop.expression.expression.arguments[0];
                    defineProperty(property, typeArgument);
                }
            }
            else if (node.getText() === "defineTypes" &&
                (node.parent.kind === ts.SyntaxKind.CallExpression ||
                    node.parent.kind === ts.SyntaxKind.PropertyAccessExpression)) {
                /**
                 * JavaScript source file (`.js`)
                 * Using `defineTypes()`
                 */
                var callExpression = (node.parent.kind === ts.SyntaxKind.PropertyAccessExpression)
                    ? node.parent.parent
                    : node.parent;
                if (callExpression.kind !== ts.SyntaxKind.CallExpression) {
                    break;
                }
                var className = callExpression.arguments[0].getText();
                currentStructure.name = className;
                var types = callExpression.arguments[1];
                for (var i = 0; i < types.properties.length; i++) {
                    var prop = types.properties[i];
                    var property = currentProperty || new types_1.Property();
                    property.name = prop.name.escapedText;
                    currentStructure.addProperty(property);
                    defineProperty(property, prop.initializer);
                }
            }
            if (node.parent.kind === ts.SyntaxKind.ClassDeclaration) {
                currentStructure.name = node.getText();
            }
            currentProperty = undefined;
            break;
    }
    ts.forEachChild(node, function (n) { return inspectNode(n, context, decoratorName); });
}
var parsedFiles;
function parseFiles(fileNames, decoratorName, context) {
    if (decoratorName === void 0) { decoratorName = "type"; }
    if (context === void 0) { context = new types_1.Context(); }
    /**
     * Re-set globalContext for each test case
     */
    if (globalContext !== context) {
        parsedFiles = {};
        globalContext = context;
    }
    fileNames.forEach(function (fileName) {
        var sourceFile;
        var sourceFileName;
        var fileNameAlternatives = [];
        if (!fileName.endsWith(".ts") && !fileName.endsWith(".js")) {
            fileNameAlternatives.push(fileName + ".ts");
            fileNameAlternatives.push(fileName + "/index.ts");
        }
        else {
            fileNameAlternatives.push(fileName);
        }
        for (var i = 0; i < fileNameAlternatives.length; i++) {
            try {
                sourceFileName = path.resolve(fileNameAlternatives[i]);
                if (parsedFiles[sourceFileName]) {
                    break;
                }
                sourceFile = ts.createSourceFile(sourceFileName, fs_1.readFileSync(sourceFileName).toString(), ts.ScriptTarget.Latest, true);
                parsedFiles[sourceFileName] = true;
                break;
            }
            catch (e) {
                // console.log(`${fileNameAlternatives[i]} => ${e.message}`);
            }
        }
        if (sourceFile) {
            inspectNode(sourceFile, context, decoratorName);
        }
    });
    return context.getStructures();
}
exports.parseFiles = parseFiles;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvZGVnZW4vcGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUFpQztBQUNqQywyQkFBNkI7QUFDN0IseUJBQWtDO0FBQ2xDLGlDQUEwRTtBQUUxRSxJQUFJLGdCQUE0QixDQUFDO0FBQ2pDLElBQUksZUFBeUIsQ0FBQztBQUU5QixJQUFJLGFBQXNCLENBQUM7QUFFM0IsU0FBUyxjQUFjLENBQUMsUUFBa0IsRUFBRSxXQUFnQjtJQUN4RCxJQUFJLEVBQUUsQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLEVBQUU7UUFDOUIsUUFBUSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDdEIsUUFBUSxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDO0tBRXpDO1NBQU0sSUFBSSxXQUFXLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsdUJBQXVCLEVBQUU7UUFDbEUsUUFBUSxDQUFDLElBQUksR0FBRyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7UUFDcEQsUUFBUSxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7S0FFbkU7U0FBTSxJQUFJLFdBQVcsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxzQkFBc0IsRUFBRTtRQUNqRSxRQUFRLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztRQUN4QixRQUFRLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0tBRXJEO1NBQU07UUFDSCxRQUFRLENBQUMsSUFBSSxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUM7S0FDcEM7QUFDTCxDQUFDO0FBRUQsU0FBUyxXQUFXLENBQUMsSUFB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QUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1IsNkRBQTZEO2FBQ2hFO1NBQ0o7UUFFRCxJQUFJLFVBQVUsRUFBRTtZQUNaLFdBQVcsQ0FBQyxVQUFVLEVBQUUsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1NBQ25EO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxPQUFPLE9BQU8sQ0FBQyxhQUFhLEVBQUUsQ0FBQztBQUNuQyxDQUFDO0FBeERELGdDQXdEQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzIGZyb20gXCJ0eXBlc2NyaXB0XCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgeyByZWFkRmlsZVN5bmMgfSBmcm9tIFwiZnNcIjtcbmltcG9ydCB7IElTdHJ1Y3R1cmUsIENsYXNzLCBJbnRlcmZhY2UsIFByb3BlcnR5LCBDb250ZXh0IH0gZnJvbSBcIi4vdHlwZXNcIjtcblxubGV0IGN1cnJlbnRTdHJ1Y3R1cmU6IElTdHJ1Y3R1cmU7XG5sZXQgY3VycmVudFByb3BlcnR5OiBQcm9wZXJ0eTtcblxubGV0IGdsb2JhbENvbnRleHQ6IENvbnRleHQ7XG5cbmZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHByb3BlcnR5OiBQcm9wZXJ0eSwgaW5pdGlhbGl6ZXI6IGFueSkge1xuICAgIGlmICh0cy5pc0lkZW50aWZpZXIoaW5pdGlhbGl6ZXIpKSB7XG4gICAgICAgIHByb3BlcnR5LnR5cGUgPSBcInJlZlwiO1xuICAgICAgICBwcm9wZXJ0eS5jaGlsZFR5cGUgPSBpbml0aWFsaXplci50ZXh0O1xuXG4gICAgfSBlbHNlIGlmIChpbml0aWFsaXplci5raW5kID09IHRzLlN5bnRheEtpbmQuT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24pIHtcbiAgICAgICAgcHJvcGVydHkudHlwZSA9IGluaXRpYWxpemVyLnByb3BlcnRpZXNbMF0ubmFtZS50ZXh0O1xuICAgICAgICBwcm9wZXJ0eS5jaGlsZFR5cGUgPSBpbml0aWFsaXplci5wcm9wZXJ0aWVzWzBdLmluaXRpYWxpemVyLnRleHQ7XG5cbiAgICB9IGVsc2UgaWYgKGluaXRpYWxpemVyLmtpbmQgPT0gdHMuU3ludGF4S2luZC5BcnJheUxpdGVyYWxFeHByZXNzaW9uKSB7XG4gICAgICAgIHByb3BlcnR5LnR5cGUgPSBcImFycmF5XCI7XG4gICAgICAgIHByb3BlcnR5LmNoaWxkVHlwZSA9IGluaXRpYWxpemVyLmVsZW1lbnRzWzBdLnRleHQ7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wZXJ0eS50eXBlID0gaW5pdGlhbGl6ZXIudGV4dDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGluc3BlY3ROb2RlKG5vZGU6IHRzLk5vZGUsIGNvbnRleHQ6IENvbnRleHQsIGRlY29yYXRvck5hbWU6IHN0cmluZykge1xuICAgIHN3aXRjaCAobm9kZS5raW5kKSB7XG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JbXBvcnRDbGF1c2U6XG4gICAgICAgICAgICBjb25zdCBzcGVjaWZpZXIgPSAobm9kZS5wYXJlbnQgYXMgYW55KS5tb2R1bGVTcGVjaWZpZXI7XG4gICAgICAgICAgICBpZiAoc3BlY2lmaWVyICYmIChzcGVjaWZpZXIudGV4dCBhcyBzdHJpbmcpLnN0YXJ0c1dpdGgoJy4nKSkgIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RGlyID0gcGF0aC5kaXJuYW1lKG5vZGUuZ2V0U291cmNlRmlsZSgpLmZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoVG9JbXBvcnQgPSBwYXRoLnJlc29sdmUoY3VycmVudERpciwgc3BlY2lmaWVyLnRleHQpO1xuICAgICAgICAgICAgICAgIHBhcnNlRmlsZXMoW3BhdGhUb0ltcG9ydF0sIGRlY29yYXRvck5hbWUsIGdsb2JhbENvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb246XG4gICAgICAgICAgICBjdXJyZW50U3RydWN0dXJlID0gbmV3IENsYXNzKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGhlcml0YWdlQ2xhdXNlcyA9IChub2RlIGFzIHRzLkNsYXNzTGlrZURlY2xhcmF0aW9uQmFzZSkuaGVyaXRhZ2VDbGF1c2VzO1xuICAgICAgICAgICAgaWYgKGhlcml0YWdlQ2xhdXNlcyAmJiBoZXJpdGFnZUNsYXVzZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIChjdXJyZW50U3RydWN0dXJlIGFzIENsYXNzKS5leHRlbmRzID0gaGVyaXRhZ2VDbGF1c2VzWzBdLnR5cGVzWzBdLmV4cHJlc3Npb24uZ2V0VGV4dCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250ZXh0LmFkZFN0cnVjdHVyZShjdXJyZW50U3RydWN0dXJlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5JbnRlcmZhY2VEZWNsYXJhdGlvbjpcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBPbmx5IGdlbmVyYXRlIEludGVyZmFjZXMgaWYgaXQgaGFzIFwiTWVzc2FnZVwiIG9uIGl0cyBuYW1lLlxuICAgICAgICAgICAgLy8gRXhhbXBsZTogTXlNZXNzYWdlXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgY29uc3QgaW50ZXJmYWNlTmFtZSA9IChub2RlIGFzIHRzLlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbikubmFtZS5lc2NhcGVkVGV4dC50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKGludGVyZmFjZU5hbWUuaW5kZXhPZihcIk1lc3NhZ2VcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFN0cnVjdHVyZSA9IG5ldyBJbnRlcmZhY2UoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RydWN0dXJlLm5hbWUgPSBpbnRlcmZhY2VOYW1lO1xuXG4gICAgICAgICAgICAgICAgY29udGV4dC5hZGRTdHJ1Y3R1cmUoY3VycmVudFN0cnVjdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuRXh0ZW5kc0tleXdvcmQ6XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhub2RlLmdldFRleHQoKSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuUHJvcGVydHlTaWduYXR1cmU6XG4gICAgICAgICAgICBpZiAoY3VycmVudFN0cnVjdHVyZSBpbnN0YW5jZW9mIEludGVyZmFjZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVyZmFjZURlY2xhcmF0aW9uID0gbm9kZS5wYXJlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmUubmFtZSAhPT0gKGludGVyZmFjZURlY2xhcmF0aW9uIGFzIHRzLlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbikubmFtZS5lc2NhcGVkVGV4dC50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgcHJvcGVydHkgaWYgZm9yIGEgYW5vdGhlciBpbnRlcmZhY2UgdGhhbiB0aGUgb25lIHdlJ3JlIGludGVyZXN0ZWQgaW4uXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGRlZmluZSBhIHByb3BlcnR5IG9mIGFuIGludGVyZmFjZVxuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gbmV3IFByb3BlcnR5KCk7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkubmFtZSA9IChub2RlIGFzIGFueSkubmFtZS5lc2NhcGVkVGV4dC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHByb3BlcnR5LnR5cGUgPSAobm9kZSBhcyBhbnkpLnR5cGUuZ2V0VGV4dCgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmUuYWRkUHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLklkZW50aWZpZXI6XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgbm9kZS5nZXRUZXh0KCkgPT09IFwiZGVwcmVjYXRlZFwiICYmXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQua2luZCAhPT0gdHMuU3ludGF4S2luZC5JbXBvcnRTcGVjaWZpZXJcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IG5ldyBQcm9wZXJ0eSgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm9wZXJ0eS5kZXByZWNhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUuZ2V0VGV4dCgpID09PSBkZWNvcmF0b3JOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcDogYW55ID0gbm9kZS5wYXJlbnQ/LnBhcmVudD8ucGFyZW50O1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BEZWNvcmF0b3IgPSBwcm9wPy5kZWNvcmF0b3JzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc0V4cHJlc3Npb24gPSBwcm9wPy5leHByZXNzaW9uPy5hcmd1bWVudHM7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBuZWl0aGVyIGEgYEB0eXBlKClgIGRlY29yYXRvciBvciBgdHlwZSgpYCBjYWxsLiBza2lwLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICghcHJvcERlY29yYXRvciAmJiAhaGFzRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB1c2luZyBhcyBkZWNvcmF0b3JcbiAgICAgICAgICAgICAgICBpZiAocHJvcERlY29yYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQ2FsbGluZyBgQHR5cGUoKWAgYXMgZGVjb3JhdG9yXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlRGVjb3JhdG9yOiBhbnkgPSBwcm9wRGVjb3JhdG9yLmZpbmQoKGRlY29yYXRvciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGRlY29yYXRvci5leHByZXNzaW9uIGFzIGFueSkuZXhwcmVzc2lvbi5lc2NhcGVkVGV4dCA9PT0gZGVjb3JhdG9yTmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfSkpLmV4cHJlc3Npb247XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHkgfHwgbmV3IFByb3BlcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5Lm5hbWUgPSBwcm9wLm5hbWUuZXNjYXBlZFRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmUuYWRkUHJvcGVydHkocHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVBcmd1bWVudCA9IHR5cGVEZWNvcmF0b3IuYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShwcm9wZXJ0eSwgdHlwZUFyZ3VtZW50KTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHByb3AuZXhwcmVzc2lvbi5hcmd1bWVudHM/LlsxXSAmJlxuICAgICAgICAgICAgICAgICAgICBwcm9wLmV4cHJlc3Npb24uZXhwcmVzc2lvbi5hcmd1bWVudHM/LlswXVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQ2FsbGluZyBgdHlwZSgpYCBhcyBhIHJlZ3VsYXIgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eSB8fCBuZXcgUHJvcGVydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkubmFtZSA9IHByb3AuZXhwcmVzc2lvbi5hcmd1bWVudHNbMV0udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0cnVjdHVyZS5hZGRQcm9wZXJ0eShwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZUFyZ3VtZW50ID0gcHJvcC5leHByZXNzaW9uLmV4cHJlc3Npb24uYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShwcm9wZXJ0eSwgdHlwZUFyZ3VtZW50KTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICBub2RlLmdldFRleHQoKSA9PT0gXCJkZWZpbmVUeXBlc1wiICYmXG4gICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5raW5kID09PSB0cy5TeW50YXhLaW5kLkNhbGxFeHByZXNzaW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LmtpbmQgPT09IHRzLlN5bnRheEtpbmQuUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSmF2YVNjcmlwdCBzb3VyY2UgZmlsZSAoYC5qc2ApXG4gICAgICAgICAgICAgICAgICogVXNpbmcgYGRlZmluZVR5cGVzKClgXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbEV4cHJlc3Npb24gPSAobm9kZS5wYXJlbnQua2luZCA9PT0gdHMuU3ludGF4S2luZC5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgICAgID8gbm9kZS5wYXJlbnQucGFyZW50IGFzIHRzLkNhbGxFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIDogbm9kZS5wYXJlbnQgYXMgdHMuQ2FsbEV4cHJlc3Npb247XG5cbiAgICAgICAgICAgICAgICBpZiAoY2FsbEV4cHJlc3Npb24ua2luZCAhPT0gdHMuU3ludGF4S2luZC5DYWxsRXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBjYWxsRXhwcmVzc2lvbi5hcmd1bWVudHNbMF0uZ2V0VGV4dCgpXG4gICAgICAgICAgICAgICAgY3VycmVudFN0cnVjdHVyZS5uYW1lID0gY2xhc3NOYW1lO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZXMgPSBjYWxsRXhwcmVzc2lvbi5hcmd1bWVudHNbMV0gYXMgYW55O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTx0eXBlcy5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSB0eXBlcy5wcm9wZXJ0aWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5IHx8IG5ldyBQcm9wZXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5uYW1lID0gcHJvcC5uYW1lLmVzY2FwZWRUZXh0O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RydWN0dXJlLmFkZFByb3BlcnR5KHByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShwcm9wZXJ0eSwgcHJvcC5pbml0aWFsaXplcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLnBhcmVudC5raW5kID09PSB0cy5TeW50YXhLaW5kLkNsYXNzRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RydWN0dXJlLm5hbWUgPSBub2RlLmdldFRleHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0cy5mb3JFYWNoQ2hpbGQobm9kZSwgKG4pID0+IGluc3BlY3ROb2RlKG4sIGNvbnRleHQsIGRlY29yYXRvck5hbWUpKTtcbn1cblxubGV0IHBhcnNlZEZpbGVzOiB7IFtmaWxlbmFtZTogc3RyaW5nXTogYm9vbGVhbiB9O1xuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VGaWxlcyhcbiAgICBmaWxlTmFtZXM6IHN0cmluZ1tdLFxuICAgIGRlY29yYXRvck5hbWU6IHN0cmluZyA9IFwidHlwZVwiLFxuICAgIGNvbnRleHQ6IENvbnRleHQgPSBuZXcgQ29udGV4dCgpXG4pIHtcbiAgICAvKipcbiAgICAgKiBSZS1zZXQgZ2xvYmFsQ29udGV4dCBmb3IgZWFjaCB0ZXN0IGNhc2VcbiAgICAgKi9cbiAgICBpZiAoZ2xvYmFsQ29udGV4dCAhPT0gY29udGV4dCkge1xuICAgICAgICBwYXJzZWRGaWxlcyA9IHt9O1xuICAgICAgICBnbG9iYWxDb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG5cbiAgICBmaWxlTmFtZXMuZm9yRWFjaCgoZmlsZU5hbWUpID0+IHtcbiAgICAgICAgbGV0IHNvdXJjZUZpbGU6IHRzLk5vZGU7XG4gICAgICAgIGxldCBzb3VyY2VGaWxlTmFtZTogc3RyaW5nO1xuXG4gICAgICAgIGNvbnN0IGZpbGVOYW1lQWx0ZXJuYXRpdmVzID0gW107XG5cbiAgICAgICAgaWYgKCFmaWxlTmFtZS5lbmRzV2l0aChcIi50c1wiKSAmJiAhZmlsZU5hbWUuZW5kc1dpdGgoXCIuanNcIikpIHtcbiAgICAgICAgICAgIGZpbGVOYW1lQWx0ZXJuYXRpdmVzLnB1c2goYCR7ZmlsZU5hbWV9LnRzYCk7XG4gICAgICAgICAgICBmaWxlTmFtZUFsdGVybmF0aXZlcy5wdXNoKGAke2ZpbGVOYW1lfS9pbmRleC50c2ApO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWxlTmFtZUFsdGVybmF0aXZlcy5wdXNoKGZpbGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsZU5hbWVBbHRlcm5hdGl2ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc291cmNlRmlsZU5hbWUgPSBwYXRoLnJlc29sdmUoZmlsZU5hbWVBbHRlcm5hdGl2ZXNbaV0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZEZpbGVzW3NvdXJjZUZpbGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzb3VyY2VGaWxlID0gdHMuY3JlYXRlU291cmNlRmlsZShcbiAgICAgICAgICAgICAgICAgICAgc291cmNlRmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJlYWRGaWxlU3luYyhzb3VyY2VGaWxlTmFtZSkudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgdHMuU2NyaXB0VGFyZ2V0LkxhdGVzdCxcbiAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBwYXJzZWRGaWxlc1tzb3VyY2VGaWxlTmFtZV0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYCR7ZmlsZU5hbWVBbHRlcm5hdGl2ZXNbaV19ID0+ICR7ZS5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNvdXJjZUZpbGUpIHtcbiAgICAgICAgICAgIGluc3BlY3ROb2RlKHNvdXJjZUZpbGUsIGNvbnRleHQsIGRlY29yYXRvck5hbWUpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udGV4dC5nZXRTdHJ1Y3R1cmVzKCk7XG59Il19