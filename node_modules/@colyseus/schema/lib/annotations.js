"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineTypes = exports.deprecated = exports.filterChildren = exports.filter = exports.type = exports.globalContext = exports.Context = exports.hasFilter = exports.SchemaDefinition = void 0;
var Schema_1 = require("./Schema");
var ArraySchema_1 = require("./types/ArraySchema");
var MapSchema_1 = require("./types/MapSchema");
var types_1 = require("./types");
var SchemaDefinition = /** @class */ (function () {
    function SchemaDefinition() {
        //
        // TODO: use a "field" structure combining all these properties per-field.
        //
        this.indexes = {};
        this.fieldsByIndex = {};
        this.deprecated = {};
        this.descriptors = {};
    }
    SchemaDefinition.create = function (parent) {
        var definition = new SchemaDefinition();
        // support inheritance
        definition.schema = Object.assign({}, parent && parent.schema || {});
        definition.indexes = Object.assign({}, parent && parent.indexes || {});
        definition.fieldsByIndex = Object.assign({}, parent && parent.fieldsByIndex || {});
        definition.descriptors = Object.assign({}, parent && parent.descriptors || {});
        definition.deprecated = Object.assign({}, parent && parent.deprecated || {});
        return definition;
    };
    SchemaDefinition.prototype.addField = function (field, type) {
        var index = this.getNextFieldIndex();
        this.fieldsByIndex[index] = field;
        this.indexes[field] = index;
        this.schema[field] = (Array.isArray(type))
            ? { array: type[0] }
            : type;
    };
    SchemaDefinition.prototype.addFilter = function (field, cb) {
        if (!this.filters) {
            this.filters = {};
            this.indexesWithFilters = [];
        }
        this.filters[this.indexes[field]] = cb;
        this.indexesWithFilters.push(this.indexes[field]);
        return true;
    };
    SchemaDefinition.prototype.addChildrenFilter = function (field, cb) {
        var index = this.indexes[field];
        var type = this.schema[field];
        if (types_1.getType(Object.keys(type)[0])) {
            if (!this.childFilters) {
                this.childFilters = {};
            }
            this.childFilters[index] = cb;
            return true;
        }
        else {
            console.warn("@filterChildren: field '" + field + "' can't have children. Ignoring filter.");
        }
    };
    SchemaDefinition.prototype.getChildrenFilter = function (field) {
        return this.childFilters && this.childFilters[this.indexes[field]];
    };
    SchemaDefinition.prototype.getNextFieldIndex = function () {
        return Object.keys(this.schema || {}).length;
    };
    return SchemaDefinition;
}());
exports.SchemaDefinition = SchemaDefinition;
function hasFilter(klass) {
    return klass._context && klass._context.useFilters;
}
exports.hasFilter = hasFilter;
var Context = /** @class */ (function () {
    function Context() {
        this.types = {};
        this.schemas = new Map();
        this.useFilters = false;
    }
    Context.prototype.has = function (schema) {
        return this.schemas.has(schema);
    };
    Context.prototype.get = function (typeid) {
        return this.types[typeid];
    };
    Context.prototype.add = function (schema, typeid) {
        if (typeid === void 0) { typeid = this.schemas.size; }
        // FIXME: move this to somewhere else?
        // support inheritance
        schema._definition = SchemaDefinition.create(schema._definition);
        schema._typeid = typeid;
        this.types[typeid] = schema;
        this.schemas.set(schema, typeid);
    };
    Context.create = function (context) {
        if (context === void 0) { context = new Context; }
        return function (definition) {
            return type(definition, context);
        };
    };
    return Context;
}());
exports.Context = Context;
exports.globalContext = new Context();
/**
 * `@type()` decorator for proxies
 */
function type(type, context) {
    if (context === void 0) { context = exports.globalContext; }
    return function (target, field) {
        var constructor = target.constructor;
        constructor._context = context;
        /*
         * static schema
         */
        if (!context.has(constructor)) {
            context.add(constructor);
        }
        var definition = constructor._definition;
        definition.addField(field, type);
        /**
         * skip if descriptor already exists for this field (`@deprecated()`)
         */
        if (definition.descriptors[field]) {
            return;
        }
        var isArray = ArraySchema_1.ArraySchema.is(type);
        var isMap = !isArray && MapSchema_1.MapSchema.is(type);
        // TODO: refactor me.
        // Allow abstract intermediary classes with no fields to be serialized
        // (See "should support an inheritance with a Schema type without fields" test)
        if (typeof (type) !== "string" && !Schema_1.Schema.is(type)) {
            var childType = Object.values(type)[0];
            if (typeof (childType) !== "string" && !context.has(childType)) {
                context.add(childType);
            }
        }
        var fieldCached = "_" + field;
        definition.descriptors[fieldCached] = {
            enumerable: false,
            configurable: false,
            writable: true,
        };
        definition.descriptors[field] = {
            get: function () {
                return this[fieldCached];
            },
            set: function (value) {
                /**
                 * Create Proxy for array or map items
                 */
                // skip if value is the same as cached.
                if (value === this[fieldCached]) {
                    return;
                }
                if (value !== undefined &&
                    value !== null) {
                    // automaticallty transform Array into ArraySchema
                    if (isArray && !(value instanceof ArraySchema_1.ArraySchema)) {
                        value = new (ArraySchema_1.ArraySchema.bind.apply(ArraySchema_1.ArraySchema, __spread([void 0], value)))();
                    }
                    // automaticallty transform Map into MapSchema
                    if (isMap && !(value instanceof MapSchema_1.MapSchema)) {
                        value = new MapSchema_1.MapSchema(value);
                    }
                    // try to turn provided structure into a Proxy
                    if (value['$proxy'] === undefined) {
                        if (isMap) {
                            value = MapSchema_1.getMapProxy(value);
                        }
                        else if (isArray) {
                            value = ArraySchema_1.getArrayProxy(value);
                        }
                    }
                    // flag the change for encoding.
                    this.$changes.change(field);
                    //
                    // call setParent() recursively for this and its child
                    // structures.
                    //
                    if (value['$changes']) {
                        value['$changes'].setParent(this, this.$changes.root, this._definition.indexes[field]);
                    }
                }
                else {
                    //
                    // Setting a field to `null` or `undefined` will delete it.
                    //
                    this.$changes.delete(field);
                }
                this[fieldCached] = value;
            },
            enumerable: true,
            configurable: true
        };
    };
}
exports.type = type;
/**
 * `@filter()` decorator for defining data filters per client
 */
function filter(cb) {
    return function (target, field) {
        var constructor = target.constructor;
        var definition = constructor._definition;
        if (definition.addFilter(field, cb)) {
            constructor._context.useFilters = true;
        }
    };
}
exports.filter = filter;
function filterChildren(cb) {
    return function (target, field) {
        var constructor = target.constructor;
        var definition = constructor._definition;
        if (definition.addChildrenFilter(field, cb)) {
            constructor._context.useFilters = true;
        }
    };
}
exports.filterChildren = filterChildren;
/**
 * `@deprecated()` flag a field as deprecated.
 * The previous `@type()` annotation should remain along with this one.
 */
function deprecated(throws, context) {
    if (throws === void 0) { throws = true; }
    if (context === void 0) { context = exports.globalContext; }
    return function (target, field) {
        var constructor = target.constructor;
        var definition = constructor._definition;
        definition.deprecated[field] = true;
        if (throws) {
            definition.descriptors[field] = {
                get: function () { throw new Error(field + " is deprecated."); },
                set: function (value) { },
                enumerable: false,
                configurable: true
            };
        }
    };
}
exports.deprecated = deprecated;
function defineTypes(target, fields, context) {
    if (context === void 0) { context = target._context || exports.globalContext; }
    for (var field in fields) {
        type(fields[field], context)(target.prototype, field);
    }
    return target;
}
exports.defineTypes = defineTypes;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ub3RhdGlvbnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvYW5ub3RhdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxtQ0FBa0M7QUFDbEMsbURBQWlFO0FBQ2pFLCtDQUEyRDtBQUMzRCxpQ0FBa0M7QUFnRGxDO0lBQUE7UUFHSSxFQUFFO1FBQ0YsMEVBQTBFO1FBQzFFLEVBQUU7UUFFRixZQUFPLEdBQWdDLEVBQUUsQ0FBQztRQUMxQyxrQkFBYSxHQUFnQyxFQUFFLENBQUM7UUFNaEQsZUFBVSxHQUFpQyxFQUFFLENBQUM7UUFDOUMsZ0JBQVcsR0FBMEMsRUFBRSxDQUFDO0lBd0Q1RCxDQUFDO0lBdERVLHVCQUFNLEdBQWIsVUFBYyxNQUF5QjtRQUNuQyxJQUFNLFVBQVUsR0FBRyxJQUFJLGdCQUFnQixFQUFFLENBQUM7UUFFMUMsc0JBQXNCO1FBQ3RCLFVBQVUsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLENBQUM7UUFDckUsVUFBVSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLElBQUksTUFBTSxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUMsQ0FBQztRQUN2RSxVQUFVLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sSUFBSSxNQUFNLENBQUMsYUFBYSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ25GLFVBQVUsQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxJQUFJLE1BQU0sQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDLENBQUM7UUFDL0UsVUFBVSxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFN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aGFuZ2VUcmVlJztcbmltcG9ydCB7IFNjaGVtYSB9IGZyb20gJy4vU2NoZW1hJztcbmltcG9ydCB7IEFycmF5U2NoZW1hLCBnZXRBcnJheVByb3h5IH0gZnJvbSAnLi90eXBlcy9BcnJheVNjaGVtYSc7XG5pbXBvcnQgeyBNYXBTY2hlbWEsIGdldE1hcFByb3h5IH0gZnJvbSAnLi90eXBlcy9NYXBTY2hlbWEnO1xuaW1wb3J0IHsgZ2V0VHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIERhdGEgdHlwZXNcbiAqL1xuZXhwb3J0IHR5cGUgUHJpbWl0aXZlVHlwZSA9XG4gICAgXCJzdHJpbmdcIiB8XG4gICAgXCJudW1iZXJcIiB8XG4gICAgXCJib29sZWFuXCIgfFxuICAgIFwiaW50OFwiIHxcbiAgICBcInVpbnQ4XCIgfFxuICAgIFwiaW50MTZcIiB8XG4gICAgXCJ1aW50MTZcIiB8XG4gICAgXCJpbnQzMlwiIHxcbiAgICBcInVpbnQzMlwiIHxcbiAgICBcImludDY0XCIgfFxuICAgIFwidWludDY0XCIgfFxuICAgIFwiZmxvYXQzMlwiIHxcbiAgICBcImZsb2F0NjRcIiB8XG4gICAgdHlwZW9mIFNjaGVtYTtcblxuZXhwb3J0IHR5cGUgRGVmaW5pdGlvblR5cGUgPSBQcmltaXRpdmVUeXBlXG4gICAgfCBQcmltaXRpdmVUeXBlW11cbiAgICB8IHsgYXJyYXk6IFByaW1pdGl2ZVR5cGUgfVxuICAgIHwgeyBtYXA6IFByaW1pdGl2ZVR5cGUgfVxuICAgIHwgeyBjb2xsZWN0aW9uOiBQcmltaXRpdmVUeXBlIH1cbiAgICB8IHsgc2V0OiBQcmltaXRpdmVUeXBlIH07XG5cbmV4cG9ydCB0eXBlIERlZmluaXRpb24gPSB7IFtmaWVsZDogc3RyaW5nXTogRGVmaW5pdGlvblR5cGUgfTtcbmV4cG9ydCB0eXBlIEZpbHRlckNhbGxiYWNrPFxuICAgIFQgZXh0ZW5kcyBTY2hlbWEgPSBhbnksXG4gICAgViA9IGFueSxcbiAgICBSIGV4dGVuZHMgU2NoZW1hID0gYW55XG4+ID0gKFxuICAgICgodGhpczogVCwgY2xpZW50OiBDbGllbnQsIHZhbHVlOiBWKSA9PiBib29sZWFuKSB8XG4gICAgKCh0aGlzOiBULCBjbGllbnQ6IENsaWVudCwgdmFsdWU6IFYsIHJvb3Q6IFIpID0+IGJvb2xlYW4pXG4pO1xuXG5leHBvcnQgdHlwZSBGaWx0ZXJDaGlsZHJlbkNhbGxiYWNrPFxuICAgIFQgZXh0ZW5kcyBTY2hlbWEgPSBhbnksXG4gICAgSyA9IGFueSxcbiAgICBWID0gYW55LFxuICAgIFIgZXh0ZW5kcyBTY2hlbWEgPSBhbnlcbj4gPSAoXG4gICAgKCh0aGlzOiBULCBjbGllbnQ6IENsaWVudCwga2V5OiBLLCB2YWx1ZTogVikgPT4gYm9vbGVhbikgfFxuICAgICgodGhpczogVCwgY2xpZW50OiBDbGllbnQsIGtleTogSywgdmFsdWU6IFYsIHJvb3Q6IFIpID0+IGJvb2xlYW4pXG4pXG5cbmV4cG9ydCBjbGFzcyBTY2hlbWFEZWZpbml0aW9uIHtcbiAgICBzY2hlbWE6IERlZmluaXRpb247XG5cbiAgICAvL1xuICAgIC8vIFRPRE86IHVzZSBhIFwiZmllbGRcIiBzdHJ1Y3R1cmUgY29tYmluaW5nIGFsbCB0aGVzZSBwcm9wZXJ0aWVzIHBlci1maWVsZC5cbiAgICAvL1xuXG4gICAgaW5kZXhlczogeyBbZmllbGQ6IHN0cmluZ106IG51bWJlciB9ID0ge307XG4gICAgZmllbGRzQnlJbmRleDogeyBbaW5kZXg6IG51bWJlcl06IHN0cmluZyB9ID0ge307XG5cbiAgICBmaWx0ZXJzOiB7IFtmaWVsZDogc3RyaW5nXTogRmlsdGVyQ2FsbGJhY2sgfTtcbiAgICBpbmRleGVzV2l0aEZpbHRlcnM6IG51bWJlcltdO1xuICAgIGNoaWxkRmlsdGVyczogeyBbZmllbGQ6IHN0cmluZ106IEZpbHRlckNoaWxkcmVuQ2FsbGJhY2sgfTsgLy8gY2hpbGRGaWx0ZXJzIGFyZSB1c2VkIG9uIE1hcCwgQXJyYXksIFNldCBpdGVtcy5cblxuICAgIGRlcHJlY2F0ZWQ6IHsgW2ZpZWxkOiBzdHJpbmddOiBib29sZWFuIH0gPSB7fTtcbiAgICBkZXNjcmlwdG9yczogUHJvcGVydHlEZXNjcmlwdG9yTWFwICYgVGhpc1R5cGU8YW55PiA9IHt9O1xuXG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnQ/OiBTY2hlbWFEZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBuZXcgU2NoZW1hRGVmaW5pdGlvbigpO1xuXG4gICAgICAgIC8vIHN1cHBvcnQgaW5oZXJpdGFuY2VcbiAgICAgICAgZGVmaW5pdGlvbi5zY2hlbWEgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQgJiYgcGFyZW50LnNjaGVtYSB8fCB7fSk7XG4gICAgICAgIGRlZmluaXRpb24uaW5kZXhlcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudCAmJiBwYXJlbnQuaW5kZXhlcyB8fCB7fSk7XG4gICAgICAgIGRlZmluaXRpb24uZmllbGRzQnlJbmRleCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudCAmJiBwYXJlbnQuZmllbGRzQnlJbmRleCB8fCB7fSk7XG4gICAgICAgIGRlZmluaXRpb24uZGVzY3JpcHRvcnMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQgJiYgcGFyZW50LmRlc2NyaXB0b3JzIHx8IHt9KTtcbiAgICAgICAgZGVmaW5pdGlvbi5kZXByZWNhdGVkID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50ICYmIHBhcmVudC5kZXByZWNhdGVkIHx8IHt9KTtcblxuICAgICAgICByZXR1cm4gZGVmaW5pdGlvbjtcbiAgICB9XG5cbiAgICBhZGRGaWVsZChmaWVsZDogc3RyaW5nLCB0eXBlOiBEZWZpbml0aW9uVHlwZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0TmV4dEZpZWxkSW5kZXgoKTtcbiAgICAgICAgdGhpcy5maWVsZHNCeUluZGV4W2luZGV4XSA9IGZpZWxkO1xuICAgICAgICB0aGlzLmluZGV4ZXNbZmllbGRdID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc2NoZW1hW2ZpZWxkXSA9IChBcnJheS5pc0FycmF5KHR5cGUpKVxuICAgICAgICAgICAgPyB7IGFycmF5OiB0eXBlWzBdIH1cbiAgICAgICAgICAgIDogdHlwZTtcbiAgICB9XG5cbiAgICBhZGRGaWx0ZXIoZmllbGQ6IHN0cmluZywgY2I6IEZpbHRlckNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcnMgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhlc1dpdGhGaWx0ZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWx0ZXJzW3RoaXMuaW5kZXhlc1tmaWVsZF1dID0gY2I7XG4gICAgICAgIHRoaXMuaW5kZXhlc1dpdGhGaWx0ZXJzLnB1c2godGhpcy5pbmRleGVzW2ZpZWxkXSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGFkZENoaWxkcmVuRmlsdGVyKGZpZWxkOiBzdHJpbmcsIGNiOiBGaWx0ZXJDaGlsZHJlbkNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbmRleGVzW2ZpZWxkXTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMuc2NoZW1hW2ZpZWxkXTtcblxuICAgICAgICBpZiAoZ2V0VHlwZShPYmplY3Qua2V5cyh0eXBlKVswXSkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGlsZEZpbHRlcnMpIHsgdGhpcy5jaGlsZEZpbHRlcnMgPSB7fTsgfVxuXG4gICAgICAgICAgICB0aGlzLmNoaWxkRmlsdGVyc1tpbmRleF0gPSBjYjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEBmaWx0ZXJDaGlsZHJlbjogZmllbGQgJyR7ZmllbGR9JyBjYW4ndCBoYXZlIGNoaWxkcmVuLiBJZ25vcmluZyBmaWx0ZXIuYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRDaGlsZHJlbkZpbHRlcihmaWVsZDogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkRmlsdGVycyAmJiB0aGlzLmNoaWxkRmlsdGVyc1t0aGlzLmluZGV4ZXNbZmllbGRdXTtcbiAgICB9XG5cbiAgICBnZXROZXh0RmllbGRJbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2NoZW1hIHx8IHt9KS5sZW5ndGg7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzRmlsdGVyKGtsYXNzOiB0eXBlb2YgU2NoZW1hKSB7XG4gICAgcmV0dXJuIGtsYXNzLl9jb250ZXh0ICYmIGtsYXNzLl9jb250ZXh0LnVzZUZpbHRlcnM7XG59XG5cbi8vIENvbHlzZXVzIGludGVncmF0aW9uXG5leHBvcnQgdHlwZSBDbGllbnQgPSB7XG4gICAgc2Vzc2lvbklkOiBzdHJpbmcsXG59ICYgYW55O1xuXG5leHBvcnQgY2xhc3MgQ29udGV4dCB7XG4gICAgdHlwZXM6IHtbaWQ6IG51bWJlcl06IHR5cGVvZiBTY2hlbWF9ID0ge307XG4gICAgc2NoZW1hcyA9IG5ldyBNYXA8dHlwZW9mIFNjaGVtYSwgbnVtYmVyPigpO1xuICAgIHVzZUZpbHRlcnMgPSBmYWxzZTtcblxuICAgIGhhcyhzY2hlbWE6IHR5cGVvZiBTY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hcy5oYXMoc2NoZW1hKTtcbiAgICB9XG5cbiAgICBnZXQodHlwZWlkOiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZXNbdHlwZWlkXTtcbiAgICB9XG5cbiAgICBhZGQoc2NoZW1hOiB0eXBlb2YgU2NoZW1hLCB0eXBlaWQ6IG51bWJlciA9IHRoaXMuc2NoZW1hcy5zaXplKSB7XG4gICAgICAgIC8vIEZJWE1FOiBtb3ZlIHRoaXMgdG8gc29tZXdoZXJlIGVsc2U/XG4gICAgICAgIC8vIHN1cHBvcnQgaW5oZXJpdGFuY2VcbiAgICAgICAgc2NoZW1hLl9kZWZpbml0aW9uID0gU2NoZW1hRGVmaW5pdGlvbi5jcmVhdGUoc2NoZW1hLl9kZWZpbml0aW9uKTtcblxuICAgICAgICBzY2hlbWEuX3R5cGVpZCA9IHR5cGVpZDtcbiAgICAgICAgdGhpcy50eXBlc1t0eXBlaWRdID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnNjaGVtYXMuc2V0KHNjaGVtYSwgdHlwZWlkKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlKGNvbnRleHQ6IENvbnRleHQgPSBuZXcgQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRlZmluaXRpb246IERlZmluaXRpb25UeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZShkZWZpbml0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdsb2JhbENvbnRleHQgPSBuZXcgQ29udGV4dCgpO1xuXG4vKipcbiAqIGBAdHlwZSgpYCBkZWNvcmF0b3IgZm9yIHByb3hpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR5cGUgKHR5cGU6IERlZmluaXRpb25UeXBlLCBjb250ZXh0OiBDb250ZXh0ID0gZ2xvYmFsQ29udGV4dCk6IFByb3BlcnR5RGVjb3JhdG9yIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldDogdHlwZW9mIFNjaGVtYSwgZmllbGQ6IHN0cmluZykge1xuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHRhcmdldC5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgU2NoZW1hO1xuICAgICAgICBjb25zdHJ1Y3Rvci5fY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogc3RhdGljIHNjaGVtYVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFjb250ZXh0Lmhhcyhjb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYWRkKGNvbnN0cnVjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBjb25zdHJ1Y3Rvci5fZGVmaW5pdGlvbjtcbiAgICAgICAgZGVmaW5pdGlvbi5hZGRGaWVsZChmaWVsZCwgdHlwZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNraXAgaWYgZGVzY3JpcHRvciBhbHJlYWR5IGV4aXN0cyBmb3IgdGhpcyBmaWVsZCAoYEBkZXByZWNhdGVkKClgKVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGRlZmluaXRpb24uZGVzY3JpcHRvcnNbZmllbGRdKSB7IHJldHVybjsgfVxuXG4gICAgICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheVNjaGVtYS5pcyh0eXBlKTtcbiAgICAgICAgY29uc3QgaXNNYXAgPSAhaXNBcnJheSAmJiBNYXBTY2hlbWEuaXModHlwZSk7XG5cbiAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgbWUuXG4gICAgICAgIC8vIEFsbG93IGFic3RyYWN0IGludGVybWVkaWFyeSBjbGFzc2VzIHdpdGggbm8gZmllbGRzIHRvIGJlIHNlcmlhbGl6ZWRcbiAgICAgICAgLy8gKFNlZSBcInNob3VsZCBzdXBwb3J0IGFuIGluaGVyaXRhbmNlIHdpdGggYSBTY2hlbWEgdHlwZSB3aXRob3V0IGZpZWxkc1wiIHRlc3QpXG4gICAgICAgIGlmICh0eXBlb2YgKHR5cGUpICE9PSBcInN0cmluZ1wiICYmICFTY2hlbWEuaXModHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkVHlwZSA9IE9iamVjdC52YWx1ZXModHlwZSlbMF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIChjaGlsZFR5cGUpICE9PSBcInN0cmluZ1wiICYmICFjb250ZXh0LmhhcyhjaGlsZFR5cGUpKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5hZGQoY2hpbGRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZpZWxkQ2FjaGVkID0gYF8ke2ZpZWxkfWA7XG5cbiAgICAgICAgZGVmaW5pdGlvbi5kZXNjcmlwdG9yc1tmaWVsZENhY2hlZF0gPSB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgfTtcblxuICAgICAgICBkZWZpbml0aW9uLmRlc2NyaXB0b3JzW2ZpZWxkXSA9IHtcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzW2ZpZWxkQ2FjaGVkXTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoaXM6IFNjaGVtYSwgdmFsdWU6IGFueSkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENyZWF0ZSBQcm94eSBmb3IgYXJyYXkgb3IgbWFwIGl0ZW1zXG4gICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAvLyBza2lwIGlmIHZhbHVlIGlzIHRoZSBzYW1lIGFzIGNhY2hlZC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHRoaXNbZmllbGRDYWNoZWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgIT09IG51bGxcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxsdHkgdHJhbnNmb3JtIEFycmF5IGludG8gQXJyYXlTY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5U2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQXJyYXlTY2hlbWEoLi4udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYXV0b21hdGljYWxsdHkgdHJhbnNmb3JtIE1hcCBpbnRvIE1hcFNjaGVtYVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXAgJiYgISh2YWx1ZSBpbnN0YW5jZW9mIE1hcFNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IE1hcFNjaGVtYSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdG8gdHVybiBwcm92aWRlZCBzdHJ1Y3R1cmUgaW50byBhIFByb3h5XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsnJHByb3h5J10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRNYXBQcm94eSh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0QXJyYXlQcm94eSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBmbGFnIHRoZSBjaGFuZ2UgZm9yIGVuY29kaW5nLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmNoYW5nZShmaWVsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbCBzZXRQYXJlbnQoKSByZWN1cnNpdmVseSBmb3IgdGhpcyBhbmQgaXRzIGNoaWxkXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cnVjdHVyZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsnJGNoYW5nZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlWyckY2hhbmdlcyddIGFzIENoYW5nZVRyZWUpLnNldFBhcmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMucm9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZWZpbml0aW9uLmluZGV4ZXNbZmllbGRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0dGluZyBhIGZpZWxkIHRvIGBudWxsYCBvciBgdW5kZWZpbmVkYCB3aWxsIGRlbGV0ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5kZWxldGUoZmllbGQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXNbZmllbGRDYWNoZWRdID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIGBAZmlsdGVyKClgIGRlY29yYXRvciBmb3IgZGVmaW5pbmcgZGF0YSBmaWx0ZXJzIHBlciBjbGllbnRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZmlsdGVyPFQgZXh0ZW5kcyBTY2hlbWEsIFYsIFIgZXh0ZW5kcyBTY2hlbWE+KGNiOiBGaWx0ZXJDYWxsYmFjazxULCBWLCBSPik6IFByb3BlcnR5RGVjb3JhdG9yIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldDogYW55LCBmaWVsZDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdGFyZ2V0LmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBTY2hlbWE7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBjb25zdHJ1Y3Rvci5fZGVmaW5pdGlvbjtcblxuICAgICAgICBpZiAoZGVmaW5pdGlvbi5hZGRGaWx0ZXIoZmllbGQsIGNiKSkge1xuICAgICAgICAgICAgY29uc3RydWN0b3IuX2NvbnRleHQudXNlRmlsdGVycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJDaGlsZHJlbjxUIGV4dGVuZHMgU2NoZW1hLCBLLCBWLCBSIGV4dGVuZHMgU2NoZW1hPihjYjogRmlsdGVyQ2hpbGRyZW5DYWxsYmFjazxULCBLLCBWLCBSPik6IFByb3BlcnR5RGVjb3JhdG9yIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldDogYW55LCBmaWVsZDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdGFyZ2V0LmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBTY2hlbWE7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBjb25zdHJ1Y3Rvci5fZGVmaW5pdGlvbjtcbiAgICAgICAgaWYgKGRlZmluaXRpb24uYWRkQ2hpbGRyZW5GaWx0ZXIoZmllbGQsIGNiKSkge1xuICAgICAgICAgICAgY29uc3RydWN0b3IuX2NvbnRleHQudXNlRmlsdGVycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuLyoqXG4gKiBgQGRlcHJlY2F0ZWQoKWAgZmxhZyBhIGZpZWxkIGFzIGRlcHJlY2F0ZWQuXG4gKiBUaGUgcHJldmlvdXMgYEB0eXBlKClgIGFubm90YXRpb24gc2hvdWxkIHJlbWFpbiBhbG9uZyB3aXRoIHRoaXMgb25lLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXByZWNhdGVkKHRocm93czogYm9vbGVhbiA9IHRydWUsIGNvbnRleHQ6IENvbnRleHQgPSBnbG9iYWxDb250ZXh0KTogUHJvcGVydHlEZWNvcmF0b3Ige1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0OiB0eXBlb2YgU2NoZW1hLCBmaWVsZDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gdGFyZ2V0LmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBTY2hlbWE7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBjb25zdHJ1Y3Rvci5fZGVmaW5pdGlvbjtcblxuICAgICAgICBkZWZpbml0aW9uLmRlcHJlY2F0ZWRbZmllbGRdID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhyb3dzKSB7XG4gICAgICAgICAgICBkZWZpbml0aW9uLmRlc2NyaXB0b3JzW2ZpZWxkXSA9IHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgdGhyb3cgbmV3IEVycm9yKGAke2ZpZWxkfSBpcyBkZXByZWNhdGVkLmApOyB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRoaXM6IFNjaGVtYSwgdmFsdWU6IGFueSkgeyAvKiB0aHJvdyBuZXcgRXJyb3IoYCR7ZmllbGR9IGlzIGRlcHJlY2F0ZWQuYCk7ICovIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lVHlwZXMoXG4gICAgdGFyZ2V0OiB0eXBlb2YgU2NoZW1hLFxuICAgIGZpZWxkczogeyBbcHJvcGVydHk6IHN0cmluZ106IERlZmluaXRpb25UeXBlIH0sXG4gICAgY29udGV4dDogQ29udGV4dCA9IHRhcmdldC5fY29udGV4dCB8fCBnbG9iYWxDb250ZXh0XG4pIHtcbiAgICBmb3IgKGxldCBmaWVsZCBpbiBmaWVsZHMpIHtcbiAgICAgICAgdHlwZShmaWVsZHNbZmllbGRdLCBjb250ZXh0KSh0YXJnZXQucHJvdG90eXBlLCBmaWVsZCk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG4iXX0=