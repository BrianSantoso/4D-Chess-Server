"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schema = void 0;
var spec_1 = require("./spec");
var annotations_1 = require("./annotations");
var encode = require("./encoding/encode");
var decode = require("./encoding/decode");
var ArraySchema_1 = require("./types/ArraySchema");
var MapSchema_1 = require("./types/MapSchema");
var CollectionSchema_1 = require("./types/CollectionSchema");
var SetSchema_1 = require("./types/SetSchema");
var ChangeTree_1 = require("./changes/ChangeTree");
var EventEmitter_1 = require("./events/EventEmitter");
var filters_1 = require("./filters");
var types_1 = require("./types");
var EncodeSchemaError = /** @class */ (function (_super) {
    __extends(EncodeSchemaError, _super);
    function EncodeSchemaError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return EncodeSchemaError;
}(Error));
function assertType(value, type, klass, field) {
    var typeofTarget;
    var allowNull = false;
    switch (type) {
        case "number":
        case "int8":
        case "uint8":
        case "int16":
        case "uint16":
        case "int32":
        case "uint32":
        case "int64":
        case "uint64":
        case "float32":
        case "float64":
            typeofTarget = "number";
            if (isNaN(value)) {
                console.log("trying to encode \"NaN\" in " + klass.constructor.name + "#" + field);
            }
            break;
        case "string":
            typeofTarget = "string";
            allowNull = true;
            break;
        case "boolean":
            // boolean is always encoded as true/false based on truthiness
            return;
    }
    if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {
        var foundValue = "'" + JSON.stringify(value) + "'" + ((value && value.constructor && " (" + value.constructor.name + ")") || '');
        throw new EncodeSchemaError("a '" + typeofTarget + "' was expected, but " + foundValue + " was provided in " + klass.constructor.name + "#" + field);
    }
}
function assertInstanceType(value, type, klass, field) {
    if (!(value instanceof type)) {
        throw new EncodeSchemaError("a '" + type.name + "' was expected, but '" + value.constructor.name + "' was provided in " + klass.constructor.name + "#" + field);
    }
}
function encodePrimitiveType(type, bytes, value, klass, field) {
    assertType(value, type, klass, field);
    var encodeFunc = encode[type];
    if (encodeFunc) {
        encodeFunc(bytes, value);
    }
    else {
        throw new EncodeSchemaError("a '" + type + "' was expected, but " + value + " was provided in " + klass.constructor.name + "#" + field);
    }
}
function decodePrimitiveType(type, bytes, it) {
    return decode[type](bytes, it);
}
/**
 * Schema encoder / decoder
 */
var Schema = /** @class */ (function () {
    // allow inherited classes to have a constructor
    function Schema() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        // fix enumerability of fields for end-user
        Object.defineProperties(this, {
            $changes: {
                value: new ChangeTree_1.ChangeTree(this, undefined, new ChangeTree_1.Root()),
                enumerable: false,
                writable: true
            },
            $listeners: {
                value: {},
                enumerable: false,
                writable: true
            },
        });
        var descriptors = this._definition.descriptors;
        if (descriptors) {
            Object.defineProperties(this, descriptors);
        }
        //
        // Assign initial values
        //
        if (args[0]) {
            this.assign(args[0]);
        }
    }
    Schema.onError = function (e) {
        console.error(e);
    };
    Schema.is = function (type) {
        return (type['_definition'] &&
            type['_definition'].schema !== undefined);
    };
    Schema.prototype.assign = function (props) {
        Object.assign(this, props);
        return this;
    };
    Object.defineProperty(Schema.prototype, "_definition", {
        get: function () { return this.constructor._definition; },
        enumerable: false,
        configurable: true
    });
    Schema.prototype.listen = function (attr, callback) {
        var _this = this;
        if (!this.$listeners[attr]) {
            this.$listeners[attr] = new EventEmitter_1.EventEmitter();
        }
        this.$listeners[attr].register(callback);
        // return un-register callback.
        return function () {
            return _this.$listeners[attr].remove(callback);
        };
    };
    Schema.prototype.decode = function (bytes, it, ref, allChanges) {
        if (it === void 0) { it = { offset: 0 }; }
        if (ref === void 0) { ref = this; }
        if (allChanges === void 0) { allChanges = new Map(); }
        var $root = this.$changes.root;
        var totalBytes = bytes.length;
        var refId = 0;
        var changes = [];
        $root.refs.set(refId, this);
        allChanges.set(refId, changes);
        while (it.offset < totalBytes) {
            var byte = bytes[it.offset++];
            if (byte == spec_1.SWITCH_TO_STRUCTURE) {
                refId = decode.number(bytes, it);
                var nextRef = $root.refs.get(refId);
                //
                // Trying to access a reference that haven't been decoded yet.
                //
                if (!nextRef) {
                    throw new Error("\"refId\" not found: " + refId);
                }
                ref = nextRef;
                // create empty list of changes for this refId.
                changes = [];
                allChanges.set(refId, changes);
                continue;
            }
            var changeTree = ref['$changes'];
            var isSchema = (ref['_definition'] !== undefined);
            var operation = (isSchema)
                ? (byte >> 6) << 6 // "compressed" index + operation
                : byte; // "uncompressed" index + operation (array/map items)
            if (operation === spec_1.OPERATION.CLEAR) {
                //
                // TODO: refactor me!
                // The `.clear()` method is calling `$root.removeRef(refId)` for
                // each item inside this collection
                //
                ref.clear(true);
                continue;
            }
            var fieldIndex = (isSchema)
                ? byte % (operation || 255) // if "REPLACE" operation (0), use 255
                : decode.number(bytes, it);
            var fieldName = (isSchema)
                ? (ref['_definition'].fieldsByIndex[fieldIndex])
                : "";
            var type = changeTree.getType(fieldIndex);
            var value = void 0;
            var previousValue = void 0;
            var dynamicIndex = void 0;
            if (!isSchema) {
                previousValue = ref['getByIndex'](fieldIndex);
                if ((operation & spec_1.OPERATION.ADD) === spec_1.OPERATION.ADD) { // ADD or DELETE_AND_ADD
                    dynamicIndex = (ref instanceof MapSchema_1.MapSchema)
                        ? decode.string(bytes, it)
                        : fieldIndex;
                    ref['setIndex'](fieldIndex, dynamicIndex);
                }
                else {
                    // here
                    dynamicIndex = ref['getIndex'](fieldIndex);
                }
            }
            else {
                previousValue = ref["_" + fieldName];
            }
            //
            // Delete operations
            //
            if ((operation & spec_1.OPERATION.DELETE) === spec_1.OPERATION.DELETE) {
                if (operation !== spec_1.OPERATION.DELETE_AND_ADD) {
                    ref['deleteByIndex'](fieldIndex);
                }
                // Flag `refId` for garbage collection.
                if (previousValue && previousValue['$changes']) {
                    $root.removeRef(previousValue['$changes'].refId);
                }
                value = null;
            }
            if (fieldName === undefined) {
                console.warn("@colyseus/schema: definition mismatch");
                //
                // keep skipping next bytes until reaches a known structure
                // by local decoder.
                //
                var nextIterator = { offset: it.offset };
                while (it.offset < totalBytes) {
                    if (decode.switchStructureCheck(bytes, it)) {
                        nextIterator.offset = it.offset + 1;
                        if ($root.refs.has(decode.number(bytes, nextIterator))) {
                            break;
                        }
                    }
                    it.offset++;
                }
                continue;
            }
            else if (operation === spec_1.OPERATION.DELETE) {
                //
                // FIXME: refactor me.
                // Don't do anything.
                //
            }
            else if (Schema.is(type)) {
                var refId_1 = decode.number(bytes, it);
                value = $root.refs.get(refId_1);
                if (operation !== spec_1.OPERATION.REPLACE) {
                    var childType = this.getSchemaType(bytes, it, type);
                    if (!value) {
                        value = this.createTypeInstance(childType);
                        value.$changes.refId = refId_1;
                        if (previousValue) {
                            value.onChange = previousValue.onChange;
                            value.onRemove = previousValue.onRemove;
                            value.$listeners = previousValue.$listeners;
                            if (previousValue['$changes'].refId &&
                                refId_1 !== previousValue['$changes'].refId) {
                                $root.removeRef(previousValue['$changes'].refId);
                            }
                        }
                    }
                    $root.addRef(refId_1, value, (value !== previousValue));
                }
            }
            else if (typeof (type) === "string") {
                //
                // primitive value (number, string, boolean, etc)
                //
                value = decodePrimitiveType(type, bytes, it);
            }
            else {
                var typeDef = types_1.getType(Object.keys(type)[0]);
                var refId_2 = decode.number(bytes, it);
                var valueRef = ($root.refs.has(refId_2))
                    ? previousValue || $root.refs.get(refId_2)
                    : new typeDef.constructor();
                value = valueRef.clone(true);
                value.$changes.refId = refId_2;
                // preserve schema callbacks
                if (previousValue) {
                    value.onAdd = previousValue.onAdd;
                    value.onRemove = previousValue.onRemove;
                    value.onChange = previousValue.onChange;
                    if (previousValue['$changes'].refId &&
                        refId_2 !== previousValue['$changes'].refId) {
                        $root.removeRef(previousValue['$changes'].refId);
                        //
                        // Trigger onRemove if structure has been replaced.
                        //
                        var deletes = [];
                        var entries = previousValue.entries();
                        var iter = void 0;
                        while ((iter = entries.next()) && !iter.done) {
                            var _a = __read(iter.value, 2), key = _a[0], value_1 = _a[1];
                            deletes.push({
                                op: spec_1.OPERATION.DELETE,
                                field: key,
                                value: undefined,
                                previousValue: value_1,
                            });
                        }
                        allChanges.set(previousValue['$changes'].refId, deletes);
                    }
                }
                $root.addRef(refId_2, value, (valueRef !== previousValue));
                //
                // TODO: deprecate proxies on next version.
                // get proxy to target value.
                //
                if (typeDef.getProxy) {
                    value = typeDef.getProxy(value);
                }
            }
            var hasChange = (previousValue !== value);
            if (value !== null &&
                value !== undefined) {
                if (value['$changes']) {
                    value['$changes'].setParent(changeTree.ref, changeTree.root, fieldIndex);
                }
                if (ref instanceof Schema) {
                    ref[fieldName] = value;
                    //
                    // FIXME: use `_field` instead of `field`.
                    //
                    // `field` is going to use the setter of the PropertyDescriptor
                    // and create a proxy for array/map. This is only useful for
                    // backwards-compatibility with @colyseus/schema@0.5.x
                    //
                    // // ref[_field] = value;
                }
                else if (ref instanceof MapSchema_1.MapSchema) {
                    // const key = ref['$indexes'].get(field);
                    var key = dynamicIndex;
                    // ref.set(key, value);
                    ref['$items'].set(key, value);
                }
                else if (ref instanceof ArraySchema_1.ArraySchema) {
                    // const key = ref['$indexes'][field];
                    // console.log("SETTING FOR ArraySchema =>", { field, key, value });
                    // ref[key] = value;
                    ref.setAt(fieldIndex, value);
                }
                else if (ref instanceof CollectionSchema_1.CollectionSchema ||
                    ref instanceof SetSchema_1.SetSchema) {
                    var index = ref.add(value);
                    ref['setIndex'](fieldIndex, index);
                }
            }
            if (hasChange
            // &&
            // (
            //     this.onChange || ref.$listeners[field]
            // )
            ) {
                changes.push({
                    op: operation,
                    field: fieldName,
                    dynamicIndex: dynamicIndex,
                    value: value,
                    previousValue: previousValue,
                });
            }
        }
        this._triggerChanges(allChanges);
        // drop references of unused schemas
        $root.garbageCollectDeletedRefs();
        return allChanges;
    };
    Schema.prototype.encode = function (encodeAll, bytes, useFilters) {
        if (encodeAll === void 0) { encodeAll = false; }
        if (bytes === void 0) { bytes = []; }
        if (useFilters === void 0) { useFilters = false; }
        var rootChangeTree = this.$changes;
        var refIdsVisited = new WeakSet();
        var changeTrees = [rootChangeTree];
        var numChangeTrees = 1;
        for (var i = 0; i < numChangeTrees; i++) {
            var changeTree = changeTrees[i];
            var ref = changeTree.ref;
            var isSchema = (ref instanceof Schema);
            // Generate unique refId for the ChangeTree.
            changeTree.ensureRefId();
            // mark this ChangeTree as visited.
            refIdsVisited.add(changeTree);
            // root `refId` is skipped.
            if (changeTree !== rootChangeTree &&
                (changeTree.changed || encodeAll)) {
                encode.uint8(bytes, spec_1.SWITCH_TO_STRUCTURE);
                encode.number(bytes, changeTree.refId);
            }
            var changes = (encodeAll)
                ? Array.from(changeTree.allChanges)
                : Array.from(changeTree.changes.values());
            for (var j = 0, cl = changes.length; j < cl; j++) {
                var operation = (encodeAll)
                    ? { op: spec_1.OPERATION.ADD, index: changes[j] }
                    : changes[j];
                var fieldIndex = operation.index;
                var field = (isSchema)
                    ? ref['_definition'].fieldsByIndex && ref['_definition'].fieldsByIndex[fieldIndex]
                    : fieldIndex;
                // cache begin index if `useFilters`
                var beginIndex = bytes.length;
                // encode field index + operation
                if (operation.op !== spec_1.OPERATION.TOUCH) {
                    if (isSchema) {
                        //
                        // Compress `fieldIndex` + `operation` into a single byte.
                        // This adds a limitaion of 64 fields per Schema structure
                        //
                        encode.uint8(bytes, (fieldIndex | operation.op));
                    }
                    else {
                        encode.uint8(bytes, operation.op);
                        // custom operations
                        if (operation.op === spec_1.OPERATION.CLEAR) {
                            continue;
                        }
                        // indexed operations
                        encode.number(bytes, fieldIndex);
                    }
                }
                //
                // encode "alias" for dynamic fields (maps)
                //
                if (!isSchema &&
                    (operation.op & spec_1.OPERATION.ADD) == spec_1.OPERATION.ADD // ADD or DELETE_AND_ADD
                ) {
                    if (ref instanceof MapSchema_1.MapSchema) {
                        //
                        // MapSchema dynamic key
                        //
                        var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);
                        encode.string(bytes, dynamicIndex);
                    }
                }
                if (operation.op === spec_1.OPERATION.DELETE) {
                    //
                    // TODO: delete from filter cache data.
                    //
                    // if (useFilters) {
                    //     delete changeTree.caches[fieldIndex];
                    // }
                    continue;
                }
                // const type = changeTree.childType || ref._schema[field];
                var type = changeTree.getType(fieldIndex);
                // const type = changeTree.getType(fieldIndex);
                var value = changeTree.getValue(fieldIndex);
                // Enqueue ChangeTree to be visited
                if (value &&
                    value['$changes'] &&
                    !refIdsVisited.has(value['$changes'])) {
                    changeTrees.push(value['$changes']);
                    value['$changes'].ensureRefId();
                    numChangeTrees++;
                }
                if (operation.op === spec_1.OPERATION.TOUCH) {
                    continue;
                }
                if (Schema.is(type)) {
                    assertInstanceType(value, type, ref, field);
                    //
                    // Encode refId for this instance.
                    // The actual instance is going to be encoded on next `changeTree` iteration.
                    //
                    encode.number(bytes, value.$changes.refId);
                    // Try to encode inherited TYPE_ID if it's an ADD operation.
                    if ((operation.op & spec_1.OPERATION.ADD) === spec_1.OPERATION.ADD) {
                        this.tryEncodeTypeId(bytes, type, value.constructor);
                    }
                }
                else if (typeof (type) === "string") {
                    //
                    // Primitive values
                    //
                    encodePrimitiveType(type, bytes, value, ref, field);
                }
                else {
                    //
                    // Custom type (MapSchema, ArraySchema, etc)
                    //
                    var definition = types_1.getType(Object.keys(type)[0]);
                    //
                    // ensure a ArraySchema has been provided
                    //
                    assertInstanceType(ref["_" + field], definition.constructor, ref, field);
                    //
                    // Encode refId for this instance.
                    // The actual instance is going to be encoded on next `changeTree` iteration.
                    //
                    encode.number(bytes, value.$changes.refId);
                }
                if (useFilters) {
                    // cache begin / end index
                    changeTree.cache(fieldIndex, bytes.slice(beginIndex));
                }
            }
            if (!encodeAll && !useFilters) {
                changeTree.discard();
            }
        }
        return bytes;
    };
    Schema.prototype.encodeAll = function (useFilters) {
        return this.encode(true, [], useFilters);
    };
    Schema.prototype.applyFilters = function (client, encodeAll) {
        if (encodeAll === void 0) { encodeAll = false; }
        var root = this;
        var refIdsDissallowed = new Set();
        var $filterState = filters_1.ClientState.get(client);
        var changeTrees = [this.$changes];
        var numChangeTrees = 1;
        var filteredBytes = [];
        var _loop_1 = function (i) {
            var changeTree = changeTrees[i];
            if (refIdsDissallowed.has(changeTree.refId)) {
                return "continue";
            }
            var ref = changeTree.ref;
            var isSchema = ref instanceof Schema;
            encode.uint8(filteredBytes, spec_1.SWITCH_TO_STRUCTURE);
            encode.number(filteredBytes, changeTree.refId);
            var clientHasRefId = $filterState.refIds.has(changeTree);
            var isEncodeAll = (encodeAll || !clientHasRefId);
            // console.log("REF:", ref.constructor.name);
            // console.log("Encode all?", isEncodeAll);
            //
            // include `changeTree` on list of known refIds by this client.
            //
            $filterState.addRefId(changeTree);
            var containerIndexes = $filterState.containerIndexes.get(changeTree);
            var changes = (isEncodeAll)
                ? Array.from(changeTree.allChanges)
                : Array.from(changeTree.changes.values());
            //
            // WORKAROUND: tries to re-evaluate previously not included @filter() attributes
            // - see "DELETE a field of Schema" test case.
            //
            if (!encodeAll &&
                isSchema &&
                ref._definition.indexesWithFilters) {
                var indexesWithFilters = ref._definition.indexesWithFilters;
                indexesWithFilters.forEach(function (indexWithFilter) {
                    if (!containerIndexes.has(indexWithFilter) &&
                        changeTree.allChanges.has(indexWithFilter)) {
                        if (isEncodeAll) {
                            changes.push(indexWithFilter);
                        }
                        else {
                            changes.push({ op: spec_1.OPERATION.ADD, index: indexWithFilter, });
                        }
                    }
                });
            }
            for (var j = 0, cl = changes.length; j < cl; j++) {
                var change = (isEncodeAll)
                    ? { op: spec_1.OPERATION.ADD, index: changes[j] }
                    : changes[j];
                // custom operations
                if (change.op === spec_1.OPERATION.CLEAR) {
                    encode.uint8(filteredBytes, change.op);
                    continue;
                }
                var fieldIndex = change.index;
                //
                // Deleting fields: encode the operation + field index
                //
                if (change.op === spec_1.OPERATION.DELETE) {
                    //
                    // DELETE operations also need to go through filtering.
                    //
                    // TODO: cache the previous value so we can access the value (primitive or `refId`)
                    // (check against `$filterState.refIds`)
                    //
                    if (isSchema) {
                        encode.uint8(filteredBytes, change.op | fieldIndex);
                    }
                    else {
                        encode.uint8(filteredBytes, change.op);
                        encode.number(filteredBytes, fieldIndex);
                    }
                    continue;
                }
                // indexed operation
                var value = changeTree.getValue(fieldIndex);
                var type = changeTree.getType(fieldIndex);
                if (isSchema) {
                    // Is a Schema!
                    var filter = (ref._definition.filters &&
                        ref._definition.filters[fieldIndex]);
                    if (filter && !filter.call(ref, client, value, root)) {
                        if (value && value['$changes']) {
                            refIdsDissallowed.add(value['$changes'].refId);
                            ;
                        }
                        continue;
                    }
                }
                else {
                    // Is a collection! (map, array, etc.)
                    var parent = changeTree.parent;
                    var filter = changeTree.getChildrenFilter();
                    if (filter && !filter.call(parent, client, ref['$indexes'].get(fieldIndex), value, root)) {
                        if (value && value['$changes']) {
                            refIdsDissallowed.add(value['$changes'].refId);
                        }
                        continue;
                    }
                }
                // visit child ChangeTree on further iteration.
                if (value['$changes']) {
                    changeTrees.push(value['$changes']);
                    numChangeTrees++;
                }
                //
                // Copy cached bytes
                //
                if (change.op !== spec_1.OPERATION.TOUCH) {
                    //
                    // TODO: refactor me!
                    //
                    if (change.op === spec_1.OPERATION.ADD || isSchema) {
                        //
                        // use cached bytes directly if is from Schema type.
                        //
                        filteredBytes = filteredBytes.concat(changeTree.caches[fieldIndex]);
                        containerIndexes.add(fieldIndex);
                    }
                    else {
                        if (containerIndexes.has(fieldIndex)) {
                            //
                            // use cached bytes if already has the field
                            //
                            filteredBytes = filteredBytes.concat(changeTree.caches[fieldIndex]);
                        }
                        else {
                            //
                            // force ADD operation if field is not known by this client.
                            //
                            containerIndexes.add(fieldIndex);
                            encode.uint8(filteredBytes, spec_1.OPERATION.ADD);
                            encode.number(filteredBytes, fieldIndex);
                            if (ref instanceof MapSchema_1.MapSchema) {
                                //
                                // MapSchema dynamic key
                                //
                                var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);
                                encode.string(filteredBytes, dynamicIndex);
                            }
                            if (value['$changes']) {
                                encode.number(filteredBytes, value['$changes'].refId);
                            }
                            else {
                                // "encodePrimitiveType" without type checking.
                                // the type checking has been done on the first .encode() call.
                                encode[type](filteredBytes, value);
                            }
                        }
                    }
                }
                else if (value['$changes'] && !isSchema) {
                    //
                    // TODO:
                    // - track ADD/REPLACE/DELETE instances on `$filterState`
                    // - do NOT always encode dynamicIndex for MapSchema.
                    //   (If client already has that key, only the first index is necessary.)
                    //
                    encode.uint8(filteredBytes, spec_1.OPERATION.ADD);
                    encode.number(filteredBytes, fieldIndex);
                    if (ref instanceof MapSchema_1.MapSchema) {
                        //
                        // MapSchema dynamic key
                        //
                        var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);
                        encode.string(filteredBytes, dynamicIndex);
                    }
                    encode.number(filteredBytes, value['$changes'].refId);
                }
            }
            ;
        };
        for (var i = 0; i < numChangeTrees; i++) {
            _loop_1(i);
        }
        return filteredBytes;
    };
    Schema.prototype.clone = function () {
        var cloned = new (this.constructor);
        var schema = this._definition.schema;
        for (var field in schema) {
            if (typeof (this[field]) === "object" &&
                typeof (this[field].clone) === "function") {
                // deep clone
                cloned[field] = this[field].clone();
            }
            else {
                // primitive values
                cloned[field] = this[field];
            }
        }
        return cloned;
    };
    Schema.prototype.triggerAll = function () {
        // skip if haven't received any remote refs yet.
        if (this.$changes.root.refs.size === 0) {
            return;
        }
        var allChanges = new Map();
        Schema.prototype._triggerAllFillChanges.call(this, this, allChanges);
        try {
            Schema.prototype._triggerChanges.call(this, allChanges);
        }
        catch (e) {
            Schema.onError(e);
        }
    };
    Schema.prototype.toJSON = function () {
        var schema = this._definition.schema;
        var deprecated = this._definition.deprecated;
        var obj = {};
        for (var field in schema) {
            if (!deprecated[field] && this[field] !== null && typeof (this[field]) !== "undefined") {
                obj[field] = (typeof (this[field]['toJSON']) === "function")
                    ? this[field]['toJSON']()
                    : this["_" + field];
            }
        }
        return obj;
    };
    Schema.prototype.discardAllChanges = function () {
        this.$changes.discardAll();
    };
    Schema.prototype.getByIndex = function (index) {
        return this[this._definition.fieldsByIndex[index]];
    };
    Schema.prototype.deleteByIndex = function (index) {
        this[this._definition.fieldsByIndex[index]] = undefined;
    };
    Schema.prototype.tryEncodeTypeId = function (bytes, type, targetType) {
        if (type._typeid !== targetType._typeid) {
            encode.uint8(bytes, spec_1.TYPE_ID);
            encode.number(bytes, targetType._typeid);
        }
    };
    Schema.prototype.getSchemaType = function (bytes, it, defaultType) {
        var type;
        if (bytes[it.offset] === spec_1.TYPE_ID) {
            it.offset++;
            type = this.constructor._context.get(decode.number(bytes, it));
        }
        return type || defaultType;
    };
    Schema.prototype.createTypeInstance = function (type) {
        var instance = new type();
        // assign root on $changes
        instance.$changes.root = this.$changes.root;
        return instance;
    };
    Schema.prototype._triggerAllFillChanges = function (ref, allChanges) {
        if (allChanges.has(ref['$changes'].refId)) {
            return;
        }
        var changes = [];
        allChanges.set(ref['$changes'].refId || 0, changes);
        if (ref instanceof Schema) {
            var schema = ref._definition.schema;
            for (var fieldName in schema) {
                var _field = "_" + fieldName;
                var value = ref[_field];
                if (value !== undefined) {
                    changes.push({
                        op: spec_1.OPERATION.ADD,
                        field: fieldName,
                        value: value,
                        previousValue: undefined
                    });
                    if (value['$changes'] !== undefined) {
                        Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);
                    }
                }
            }
        }
        else {
            var entries = ref.entries();
            var iter = void 0;
            while ((iter = entries.next()) && !iter.done) {
                var _a = __read(iter.value, 2), key = _a[0], value = _a[1];
                changes.push({
                    op: spec_1.OPERATION.ADD,
                    field: key,
                    dynamicIndex: key,
                    value: value,
                    previousValue: undefined,
                });
                if (value['$changes'] !== undefined) {
                    Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);
                }
            }
        }
    };
    Schema.prototype._triggerChanges = function (allChanges) {
        var _this = this;
        allChanges.forEach(function (changes, refId) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
            if (changes.length > 0) {
                var ref = _this.$changes.root.refs.get(refId);
                var isSchema = ref instanceof Schema;
                for (var i = 0; i < changes.length; i++) {
                    var change = changes[i];
                    var listener = ref['$listeners'] && ref['$listeners'][change.field];
                    if (!isSchema) {
                        if (change.op === spec_1.OPERATION.ADD && change.previousValue === undefined) {
                            (_b = (_a = ref).onAdd) === null || _b === void 0 ? void 0 : _b.call(_a, change.value, (_c = change.dynamicIndex) !== null && _c !== void 0 ? _c : change.field);
                        }
                        else if (change.op === spec_1.OPERATION.DELETE) {
                            //
                            // FIXME: `previousValue` should always be avaiiable.
                            // ADD + DELETE operations are still encoding DELETE operation.
                            //
                            if (change.previousValue !== undefined) {
                                (_e = (_d = ref).onRemove) === null || _e === void 0 ? void 0 : _e.call(_d, change.previousValue, (_f = change.dynamicIndex) !== null && _f !== void 0 ? _f : change.field);
                            }
                        }
                        else if (change.op === spec_1.OPERATION.DELETE_AND_ADD) {
                            if (change.previousValue !== undefined) {
                                (_h = (_g = ref).onRemove) === null || _h === void 0 ? void 0 : _h.call(_g, change.previousValue, change.dynamicIndex);
                            }
                            (_k = (_j = ref).onAdd) === null || _k === void 0 ? void 0 : _k.call(_j, change.value, change.dynamicIndex);
                        }
                        else if (change.op === spec_1.OPERATION.REPLACE ||
                            change.value !== change.previousValue) {
                            (_m = (_l = ref).onChange) === null || _m === void 0 ? void 0 : _m.call(_l, change.value, change.dynamicIndex);
                        }
                    }
                    //
                    // trigger onRemove on child structure.
                    //
                    if ((change.op & spec_1.OPERATION.DELETE) === spec_1.OPERATION.DELETE &&
                        change.previousValue instanceof Schema &&
                        change.previousValue.onRemove) {
                        change.previousValue.onRemove();
                    }
                    if (listener) {
                        try {
                            listener.invoke(change.value, change.previousValue);
                        }
                        catch (e) {
                            Schema.onError(e);
                        }
                    }
                }
                if (isSchema) {
                    if (ref.onChange) {
                        try {
                            ref.onChange(changes);
                        }
                        catch (e) {
                            Schema.onError(e);
                        }
                    }
                }
            }
        });
    };
    Schema._definition = annotations_1.SchemaDefinition.create();
    return Schema;
}());
exports.Schema = Schema;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU2NoZW1hLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL1NjaGVtYS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLCtCQUFpRTtBQUNqRSw2Q0FBaUc7QUFFakcsMENBQTRDO0FBQzVDLDBDQUE0QztBQUU1QyxtREFBa0Q7QUFDbEQsK0NBQThDO0FBQzlDLDZEQUE0RDtBQUM1RCwrQ0FBOEM7QUFFOUMsbURBQThFO0FBRTlFLHNEQUFxRDtBQUNyRCxxQ0FBd0M7QUFDeEMsaUNBQWtDO0FBbUJsQztJQUFnQyxxQ0FBSztJQUFyQzs7SUFBdUMsQ0FBQztJQUFELHdCQUFDO0FBQUQsQ0FBQyxBQUF4QyxDQUFnQyxLQUFLLEdBQUc7QUFFeEMsU0FBUyxVQUFVLENBQUMsS0FBVSxFQUFFLElBQVksRUFBRSxLQUFhLEVBQUUsS0FBc0I7SUFDL0UsSUFBSSxZQUFvQixDQUFDO0lBQ3pCLElBQUksU0FBUyxHQUFZLEtBQUssQ0FBQztJQUUvQixRQUFRLElBQUksRUFBRTtRQUNWLEtBQUssUUFBUSxDQUFDO1FBQ2QsS0FBSyxNQUFNLENBQUM7UUFDWixLQUFLLE9BQU8sQ0FBQztRQUNiLEtBQUssT0FBTyxDQUFDO1FBQ2IsS0FBSyxRQUFRLENBQUM7UUFDZCxLQUFLLE9BQU8sQ0FBQztRQUNiLEtBQUssUUFBUSxDQUFDO1FBQ2QsS0FBSyxPQUFPLENBQUM7UUFDYixLQUFLLFFBQVEsQ0FBQztRQUNkLEtBQUssU0FBUyxDQUFDO1FBQ2YsS0FBSyxTQUFTO1lBQ1YsWUFBWSxHQUFHLFFBQVEsQ0FBQztZQUN4QixJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDZCxPQUFPLENBQUMsR0FBRyxDQUFDLGlDQUE2QixLQUFLLENBQUMsV0FBVyxDQUFDLElBQUksU0FBSSxLQUFPLENBQUMsQ0FBQzthQUMvRTtZQUNELE1BQU07UUFDVixLQUFLLFFBQVE7WUFDVCxZQUFZLEdBQUcs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Y2VzQ29udGVudCI6WyJpbXBvcnQgeyBTV0lUQ0hfVE9fU1RSVUNUVVJFLCBUWVBFX0lELCBPUEVSQVRJT04gfSBmcm9tICcuL3NwZWMnO1xuaW1wb3J0IHsgQ2xpZW50LCBQcmltaXRpdmVUeXBlLCBDb250ZXh0LCBTY2hlbWFEZWZpbml0aW9uLCBEZWZpbml0aW9uVHlwZSB9IGZyb20gXCIuL2Fubm90YXRpb25zXCI7XG5cbmltcG9ydCAqIGFzIGVuY29kZSBmcm9tIFwiLi9lbmNvZGluZy9lbmNvZGVcIjtcbmltcG9ydCAqIGFzIGRlY29kZSBmcm9tIFwiLi9lbmNvZGluZy9kZWNvZGVcIjtcblxuaW1wb3J0IHsgQXJyYXlTY2hlbWEgfSBmcm9tIFwiLi90eXBlcy9BcnJheVNjaGVtYVwiO1xuaW1wb3J0IHsgTWFwU2NoZW1hIH0gZnJvbSBcIi4vdHlwZXMvTWFwU2NoZW1hXCI7XG5pbXBvcnQgeyBDb2xsZWN0aW9uU2NoZW1hIH0gZnJvbSAnLi90eXBlcy9Db2xsZWN0aW9uU2NoZW1hJztcbmltcG9ydCB7IFNldFNjaGVtYSB9IGZyb20gJy4vdHlwZXMvU2V0U2NoZW1hJztcblxuaW1wb3J0IHsgQ2hhbmdlVHJlZSwgUm9vdCwgUmVmLCBDaGFuZ2VPcGVyYXRpb24gfSBmcm9tIFwiLi9jaGFuZ2VzL0NoYW5nZVRyZWVcIjtcbmltcG9ydCB7IE5vbkZ1bmN0aW9uUHJvcE5hbWVzIH0gZnJvbSAnLi90eXBlcy9IZWxwZXJUeXBlcyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICcuL2V2ZW50cy9FdmVudEVtaXR0ZXInO1xuaW1wb3J0IHsgQ2xpZW50U3RhdGUgfSBmcm9tICcuL2ZpbHRlcnMnO1xuaW1wb3J0IHsgZ2V0VHlwZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFDaGFuZ2U8VD1hbnk+IHtcbiAgICBvcDogT1BFUkFUSU9OLFxuICAgIGZpZWxkOiBzdHJpbmc7XG4gICAgZHluYW1pY0luZGV4PzogbnVtYmVyIHwgc3RyaW5nO1xuICAgIHZhbHVlOiBUO1xuICAgIHByZXZpb3VzVmFsdWU6IFQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NoZW1hRGVjb2RlckNhbGxiYWNrcyB7XG4gICAgb25BZGQ/OiAoaXRlbTogYW55LCBrZXk6IGFueSkgPT4gdm9pZDtcbiAgICBvblJlbW92ZT86IChpdGVtOiBhbnksIGtleTogYW55KSA9PiB2b2lkO1xuICAgIG9uQ2hhbmdlPzogKGl0ZW06IGFueSwga2V5OiBhbnkpID0+IHZvaWQ7XG4gICAgY2xvbmUoZGVjb2Rpbmc/OiBib29sZWFuKTogU2NoZW1hRGVjb2RlckNhbGxiYWNrcztcbiAgICBjbGVhcihkZWNvZGluZz86IGJvb2xlYW4pO1xuICAgIGRlY29kZT8oYnl0ZSwgaXQ6IGRlY29kZS5JdGVyYXRvcik7XG59XG5cbmNsYXNzIEVuY29kZVNjaGVtYUVycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuZnVuY3Rpb24gYXNzZXJ0VHlwZSh2YWx1ZTogYW55LCB0eXBlOiBzdHJpbmcsIGtsYXNzOiBTY2hlbWEsIGZpZWxkOiBzdHJpbmcgfCBudW1iZXIpIHtcbiAgICBsZXQgdHlwZW9mVGFyZ2V0OiBzdHJpbmc7XG4gICAgbGV0IGFsbG93TnVsbDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcImludDhcIjpcbiAgICAgICAgY2FzZSBcInVpbnQ4XCI6XG4gICAgICAgIGNhc2UgXCJpbnQxNlwiOlxuICAgICAgICBjYXNlIFwidWludDE2XCI6XG4gICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgIGNhc2UgXCJpbnQ2NFwiOlxuICAgICAgICBjYXNlIFwidWludDY0XCI6XG4gICAgICAgIGNhc2UgXCJmbG9hdDMyXCI6XG4gICAgICAgIGNhc2UgXCJmbG9hdDY0XCI6XG4gICAgICAgICAgICB0eXBlb2ZUYXJnZXQgPSBcIm51bWJlclwiO1xuICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGB0cnlpbmcgdG8gZW5jb2RlIFwiTmFOXCIgaW4gJHtrbGFzcy5jb25zdHJ1Y3Rvci5uYW1lfSMke2ZpZWxkfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHR5cGVvZlRhcmdldCA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgICBhbGxvd051bGwgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAvLyBib29sZWFuIGlzIGFsd2F5cyBlbmNvZGVkIGFzIHRydWUvZmFsc2UgYmFzZWQgb24gdHJ1dGhpbmVzc1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gdHlwZW9mVGFyZ2V0ICYmICghYWxsb3dOdWxsIHx8IChhbGxvd051bGwgJiYgdmFsdWUgIT09IG51bGwpKSkge1xuICAgICAgICBsZXQgZm91bmRWYWx1ZSA9IGAnJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9JyR7KHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIGAgKCR7dmFsdWUuY29uc3RydWN0b3IubmFtZX0pYCkgfHwgJyd9YDtcbiAgICAgICAgdGhyb3cgbmV3IEVuY29kZVNjaGVtYUVycm9yKGBhICcke3R5cGVvZlRhcmdldH0nIHdhcyBleHBlY3RlZCwgYnV0ICR7Zm91bmRWYWx1ZX0gd2FzIHByb3ZpZGVkIGluICR7a2xhc3MuY29uc3RydWN0b3IubmFtZX0jJHtmaWVsZH1gKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydEluc3RhbmNlVHlwZShcbiAgICB2YWx1ZTogU2NoZW1hLFxuICAgIHR5cGU6IHR5cGVvZiBTY2hlbWFcbiAgICAgICAgfCB0eXBlb2YgQXJyYXlTY2hlbWFcbiAgICAgICAgfCB0eXBlb2YgTWFwU2NoZW1hXG4gICAgICAgIHwgdHlwZW9mIENvbGxlY3Rpb25TY2hlbWFcbiAgICAgICAgfCB0eXBlb2YgU2V0U2NoZW1hLFxuICAgIGtsYXNzOiBTY2hlbWEsXG4gICAgZmllbGQ6IHN0cmluZyB8IG51bWJlcixcbikge1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgdHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVuY29kZVNjaGVtYUVycm9yKGBhICcke3R5cGUubmFtZX0nIHdhcyBleHBlY3RlZCwgYnV0ICckeyh2YWx1ZSBhcyBhbnkpLmNvbnN0cnVjdG9yLm5hbWV9JyB3YXMgcHJvdmlkZWQgaW4gJHtrbGFzcy5jb25zdHJ1Y3Rvci5uYW1lfSMke2ZpZWxkfWApO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZW5jb2RlUHJpbWl0aXZlVHlwZShcbiAgICB0eXBlOiBQcmltaXRpdmVUeXBlLFxuICAgIGJ5dGVzOiBudW1iZXJbXSxcbiAgICB2YWx1ZTogYW55LFxuICAgIGtsYXNzOiBTY2hlbWEsXG4gICAgZmllbGQ6IHN0cmluZyB8IG51bWJlcixcbikge1xuICAgIGFzc2VydFR5cGUodmFsdWUsIHR5cGUgYXMgc3RyaW5nLCBrbGFzcywgZmllbGQpO1xuXG4gICAgY29uc3QgZW5jb2RlRnVuYyA9IGVuY29kZVt0eXBlIGFzIHN0cmluZ107XG5cbiAgICBpZiAoZW5jb2RlRnVuYykge1xuICAgICAgICBlbmNvZGVGdW5jKGJ5dGVzLCB2YWx1ZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRW5jb2RlU2NoZW1hRXJyb3IoYGEgJyR7dHlwZX0nIHdhcyBleHBlY3RlZCwgYnV0ICR7dmFsdWV9IHdhcyBwcm92aWRlZCBpbiAke2tsYXNzLmNvbnN0cnVjdG9yLm5hbWV9IyR7ZmllbGR9YCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkZWNvZGVQcmltaXRpdmVUeXBlICh0eXBlOiBzdHJpbmcsIGJ5dGVzOiBudW1iZXJbXSwgaXQ6IGRlY29kZS5JdGVyYXRvcikge1xuICAgIHJldHVybiBkZWNvZGVbdHlwZSBhcyBzdHJpbmddKGJ5dGVzLCBpdCk7XG59XG5cbi8qKlxuICogU2NoZW1hIGVuY29kZXIgLyBkZWNvZGVyXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTY2hlbWEge1xuICAgIHN0YXRpYyBfdHlwZWlkOiBudW1iZXI7XG4gICAgc3RhdGljIF9jb250ZXh0OiBDb250ZXh0O1xuXG4gICAgc3RhdGljIF9kZWZpbml0aW9uOiBTY2hlbWFEZWZpbml0aW9uID0gU2NoZW1hRGVmaW5pdGlvbi5jcmVhdGUoKTtcblxuICAgIHN0YXRpYyBvbkVycm9yKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgaXModHlwZTogRGVmaW5pdGlvblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHR5cGVbJ19kZWZpbml0aW9uJ10gJiZcbiAgICAgICAgICAgIHR5cGVbJ19kZWZpbml0aW9uJ10uc2NoZW1hICE9PSB1bmRlZmluZWRcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgJGNoYW5nZXM6IENoYW5nZVRyZWU7XG4gICAgLy8gcHJvdGVjdGVkICRyb290OiBDaGFuZ2VTZXQ7XG5cbiAgICBwcm90ZWN0ZWQgJGxpc3RlbmVyczogeyBbZmllbGQ6IHN0cmluZ106IEV2ZW50RW1pdHRlcjwoYTogYW55LCBiOiBhbnkpID0+IHZvaWQ+IH07XG5cbiAgICBwdWJsaWMgb25DaGFuZ2U/KGNoYW5nZXM6IERhdGFDaGFuZ2VbXSk7XG4gICAgcHVibGljIG9uUmVtb3ZlPygpO1xuXG4gICAgLy8gYWxsb3cgaW5oZXJpdGVkIGNsYXNzZXMgdG8gaGF2ZSBhIGNvbnN0cnVjdG9yXG4gICAgY29uc3RydWN0b3IoLi4uYXJnczogYW55W10pIHtcbiAgICAgICAgLy8gZml4IGVudW1lcmFiaWxpdHkgb2YgZmllbGRzIGZvciBlbmQtdXNlclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICAgICAgICAkY2hhbmdlczoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgQ2hhbmdlVHJlZSh0aGlzLCB1bmRlZmluZWQsIG5ldyBSb290KCkpLFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAkbGlzdGVuZXJzOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHt9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2RlZmluaXRpb24uZGVzY3JpcHRvcnM7XG4gICAgICAgIGlmIChkZXNjcmlwdG9ycykge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcywgZGVzY3JpcHRvcnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQXNzaWduIGluaXRpYWwgdmFsdWVzXG4gICAgICAgIC8vXG4gICAgICAgIGlmIChhcmdzWzBdKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2lnbihhcmdzWzBdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBhc3NpZ24oXG4gICAgICAgIHByb3BzOiB7IFtwcm9wIGluIE5vbkZ1bmN0aW9uUHJvcE5hbWVzPHRoaXM+XT86IHRoaXNbcHJvcF0gfVxuICAgICkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCBfZGVmaW5pdGlvbiAoKSB7IHJldHVybiAodGhpcy5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgU2NoZW1hKS5fZGVmaW5pdGlvbjsgfVxuXG4gICAgcHVibGljIGxpc3RlbiA8SyBleHRlbmRzIE5vbkZ1bmN0aW9uUHJvcE5hbWVzPHRoaXM+PihhdHRyOiBLLCBjYWxsYmFjazogKHZhbHVlOiB0aGlzW0tdLCBwcmV2aW91c1ZhbHVlOiB0aGlzW0tdKSA9PiB2b2lkKSB7XG4gICAgICAgIGlmICghdGhpcy4kbGlzdGVuZXJzW2F0dHIgYXMgc3RyaW5nXSkge1xuICAgICAgICAgICAgdGhpcy4kbGlzdGVuZXJzW2F0dHIgYXMgc3RyaW5nXSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiRsaXN0ZW5lcnNbYXR0ciBhcyBzdHJpbmddLnJlZ2lzdGVyKGNhbGxiYWNrKTtcblxuICAgICAgICAvLyByZXR1cm4gdW4tcmVnaXN0ZXIgY2FsbGJhY2suXG4gICAgICAgIHJldHVybiAoKSA9PlxuICAgICAgICAgICAgdGhpcy4kbGlzdGVuZXJzW2F0dHIgYXMgc3RyaW5nXS5yZW1vdmUoY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGRlY29kZShcbiAgICAgICAgYnl0ZXM6IG51bWJlcltdLFxuICAgICAgICBpdDogZGVjb2RlLkl0ZXJhdG9yID0geyBvZmZzZXQ6IDAgfSxcbiAgICAgICAgcmVmOiBSZWYgPSB0aGlzLFxuICAgICAgICBhbGxDaGFuZ2VzOiBNYXA8bnVtYmVyLCBEYXRhQ2hhbmdlW10+ID0gbmV3IE1hcDxudW1iZXIsIERhdGFDaGFuZ2VbXT4oKSxcbiAgICApIHtcbiAgICAgICAgY29uc3QgJHJvb3QgPSB0aGlzLiRjaGFuZ2VzLnJvb3Q7XG4gICAgICAgIGNvbnN0IHRvdGFsQnl0ZXMgPSBieXRlcy5sZW5ndGg7XG5cbiAgICAgICAgbGV0IHJlZklkOiBudW1iZXIgPSAwO1xuICAgICAgICBsZXQgY2hhbmdlczogRGF0YUNoYW5nZVtdID0gW107XG5cbiAgICAgICAgJHJvb3QucmVmcy5zZXQocmVmSWQsIHRoaXMpO1xuICAgICAgICBhbGxDaGFuZ2VzLnNldChyZWZJZCwgY2hhbmdlcyk7XG5cbiAgICAgICAgd2hpbGUgKGl0Lm9mZnNldCA8IHRvdGFsQnl0ZXMpIHtcbiAgICAgICAgICAgIGxldCBieXRlID0gYnl0ZXNbaXQub2Zmc2V0KytdO1xuXG4gICAgICAgICAgICBpZiAoYnl0ZSA9PSBTV0lUQ0hfVE9fU1RSVUNUVVJFKSB7XG4gICAgICAgICAgICAgICAgcmVmSWQgPSBkZWNvZGUubnVtYmVyKGJ5dGVzLCBpdCk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UmVmID0gJHJvb3QucmVmcy5nZXQocmVmSWQpIGFzIFNjaGVtYTtcblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gVHJ5aW5nIHRvIGFjY2VzcyBhIHJlZmVyZW5jZSB0aGF0IGhhdmVuJ3QgYmVlbiBkZWNvZGVkIHlldC5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmICghbmV4dFJlZikgeyB0aHJvdyBuZXcgRXJyb3IoYFwicmVmSWRcIiBub3QgZm91bmQ6ICR7cmVmSWR9YCk7IH1cblxuICAgICAgICAgICAgICAgIHJlZiA9IG5leHRSZWY7XG5cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgZW1wdHkgbGlzdCBvZiBjaGFuZ2VzIGZvciB0aGlzIHJlZklkLlxuICAgICAgICAgICAgICAgIGNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBhbGxDaGFuZ2VzLnNldChyZWZJZCwgY2hhbmdlcyk7XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZTogQ2hhbmdlVHJlZSA9IHJlZlsnJGNoYW5nZXMnXTtcbiAgICAgICAgICAgIGNvbnN0IGlzU2NoZW1hID0gKHJlZlsnX2RlZmluaXRpb24nXSAhPT0gdW5kZWZpbmVkKTtcblxuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gKGlzU2NoZW1hKVxuICAgICAgICAgICAgICAgID8gKGJ5dGUgPj4gNikgPDwgNiAvLyBcImNvbXByZXNzZWRcIiBpbmRleCArIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgIDogYnl0ZTsgLy8gXCJ1bmNvbXByZXNzZWRcIiBpbmRleCArIG9wZXJhdGlvbiAoYXJyYXkvbWFwIGl0ZW1zKVxuXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uID09PSBPUEVSQVRJT04uQ0xFQVIpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIG1lIVxuICAgICAgICAgICAgICAgIC8vIFRoZSBgLmNsZWFyKClgIG1ldGhvZCBpcyBjYWxsaW5nIGAkcm9vdC5yZW1vdmVSZWYocmVmSWQpYCBmb3JcbiAgICAgICAgICAgICAgICAvLyBlYWNoIGl0ZW0gaW5zaWRlIHRoaXMgY29sbGVjdGlvblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgKHJlZiBhcyBTY2hlbWFEZWNvZGVyQ2FsbGJhY2tzKS5jbGVhcih0cnVlKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgZmllbGRJbmRleCA9IChpc1NjaGVtYSlcbiAgICAgICAgICAgICAgICA/IGJ5dGUgJSAob3BlcmF0aW9uIHx8IDI1NSkgLy8gaWYgXCJSRVBMQUNFXCIgb3BlcmF0aW9uICgwKSwgdXNlIDI1NVxuICAgICAgICAgICAgICAgIDogZGVjb2RlLm51bWJlcihieXRlcywgaXQpO1xuXG4gICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSAoaXNTY2hlbWEpXG4gICAgICAgICAgICAgICAgPyAocmVmWydfZGVmaW5pdGlvbiddLmZpZWxkc0J5SW5kZXhbZmllbGRJbmRleF0pXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuXG4gICAgICAgICAgICBsZXQgdHlwZSA9IGNoYW5nZVRyZWUuZ2V0VHlwZShmaWVsZEluZGV4KTtcbiAgICAgICAgICAgIGxldCB2YWx1ZTogYW55O1xuICAgICAgICAgICAgbGV0IHByZXZpb3VzVmFsdWU6IGFueTtcblxuICAgICAgICAgICAgbGV0IGR5bmFtaWNJbmRleDogbnVtYmVyIHwgc3RyaW5nO1xuXG4gICAgICAgICAgICBpZiAoIWlzU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IHJlZlsnZ2V0QnlJbmRleCddKGZpZWxkSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKChvcGVyYXRpb24gJiBPUEVSQVRJT04uQUREKSA9PT0gT1BFUkFUSU9OLkFERCkgeyAvLyBBREQgb3IgREVMRVRFX0FORF9BRERcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pY0luZGV4ID0gKHJlZiBpbnN0YW5jZW9mIE1hcFNjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZGVjb2RlLnN0cmluZyhieXRlcywgaXQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHJlZlsnc2V0SW5kZXgnXShmaWVsZEluZGV4LCBkeW5hbWljSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGVyZVxuICAgICAgICAgICAgICAgICAgICBkeW5hbWljSW5kZXggPSByZWZbJ2dldEluZGV4J10oZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSByZWZbYF8ke2ZpZWxkTmFtZX1gXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIERlbGV0ZSBvcGVyYXRpb25zXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKChvcGVyYXRpb24gJiBPUEVSQVRJT04uREVMRVRFKSA9PT0gT1BFUkFUSU9OLkRFTEVURSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uICE9PSBPUEVSQVRJT04uREVMRVRFX0FORF9BREQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmWydkZWxldGVCeUluZGV4J10oZmllbGRJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRmxhZyBgcmVmSWRgIGZvciBnYXJiYWdlIGNvbGxlY3Rpb24uXG4gICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgJiYgcHJldmlvdXNWYWx1ZVsnJGNoYW5nZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAkcm9vdC5yZW1vdmVSZWYocHJldmlvdXNWYWx1ZVsnJGNoYW5nZXMnXS5yZWZJZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJAY29seXNldXMvc2NoZW1hOiBkZWZpbml0aW9uIG1pc21hdGNoXCIpO1xuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBrZWVwIHNraXBwaW5nIG5leHQgYnl0ZXMgdW50aWwgcmVhY2hlcyBhIGtub3duIHN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIC8vIGJ5IGxvY2FsIGRlY29kZXIuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0SXRlcmF0b3I6IGRlY29kZS5JdGVyYXRvciA9IHsgb2Zmc2V0OiBpdC5vZmZzZXQgfTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaXQub2Zmc2V0IDwgdG90YWxCeXRlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVjb2RlLnN3aXRjaFN0cnVjdHVyZUNoZWNrKGJ5dGVzLCBpdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJdGVyYXRvci5vZmZzZXQgPSBpdC5vZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRyb290LnJlZnMuaGFzKGRlY29kZS5udW1iZXIoYnl0ZXMsIG5leHRJdGVyYXRvcikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpdC5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09IE9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiByZWZhY3RvciBtZS5cbiAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZy5cbiAgICAgICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFNjaGVtYS5pcyh0eXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZklkID0gZGVjb2RlLm51bWJlcihieXRlcywgaXQpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gJHJvb3QucmVmcy5nZXQocmVmSWQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbiAhPT0gT1BFUkFUSU9OLlJFUExBQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGRUeXBlID0gdGhpcy5nZXRTY2hlbWFUeXBlKGJ5dGVzLCBpdCwgdHlwZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNyZWF0ZVR5cGVJbnN0YW5jZShjaGlsZFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUuJGNoYW5nZXMucmVmSWQgPSByZWZJZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5vbkNoYW5nZSA9IHByZXZpb3VzVmFsdWUub25DaGFuZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUub25SZW1vdmUgPSBwcmV2aW91c1ZhbHVlLm9uUmVtb3ZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLiRsaXN0ZW5lcnMgPSBwcmV2aW91c1ZhbHVlLiRsaXN0ZW5lcnM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmSWQgIT09IHByZXZpb3VzVmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3QucmVtb3ZlUmVmKHByZXZpb3VzVmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICRyb290LmFkZFJlZihyZWZJZCwgdmFsdWUsICh2YWx1ZSAhPT0gcHJldmlvdXNWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKHR5cGUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmUgdmFsdWUgKG51bWJlciwgc3RyaW5nLCBib29sZWFuLCBldGMpXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlY29kZVByaW1pdGl2ZVR5cGUodHlwZSBhcyBzdHJpbmcsIGJ5dGVzLCBpdCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZURlZiA9IGdldFR5cGUoT2JqZWN0LmtleXModHlwZSlbMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZklkID0gZGVjb2RlLm51bWJlcihieXRlcywgaXQpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVSZWY6IFNjaGVtYURlY29kZXJDYWxsYmFja3MgPSAoJHJvb3QucmVmcy5oYXMocmVmSWQpKVxuICAgICAgICAgICAgICAgICAgICA/IHByZXZpb3VzVmFsdWUgfHwgJHJvb3QucmVmcy5nZXQocmVmSWQpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IHR5cGVEZWYuY29uc3RydWN0b3IoKTtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVSZWYuY2xvbmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUuJGNoYW5nZXMucmVmSWQgPSByZWZJZDtcblxuICAgICAgICAgICAgICAgIC8vIHByZXNlcnZlIHNjaGVtYSBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5vbkFkZCA9IHByZXZpb3VzVmFsdWUub25BZGQ7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLm9uUmVtb3ZlID0gcHJldmlvdXNWYWx1ZS5vblJlbW92ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUub25DaGFuZ2UgPSBwcmV2aW91c1ZhbHVlLm9uQ2hhbmdlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZklkICE9PSBwcmV2aW91c1ZhbHVlWyckY2hhbmdlcyddLnJlZklkXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHJvb3QucmVtb3ZlUmVmKHByZXZpb3VzVmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBvblJlbW92ZSBpZiBzdHJ1Y3R1cmUgaGFzIGJlZW4gcmVwbGFjZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlczogRGF0YUNoYW5nZVtdID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzOiBJdGVyYWJsZUl0ZXJhdG9yPFthbnksIGFueV0+ID0gcHJldmlvdXNWYWx1ZS5lbnRyaWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaXRlcjogSXRlcmF0b3JSZXN1bHQ8W2FueSwgYW55XT47XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGl0ZXIgPSBlbnRyaWVzLm5leHQoKSkgJiYgIWl0ZXIuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IGl0ZXIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3A6IE9QRVJBVElPTi5ERUxFVEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxDaGFuZ2VzLnNldChwcmV2aW91c1ZhbHVlWyckY2hhbmdlcyddLnJlZklkLCBkZWxldGVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICRyb290LmFkZFJlZihyZWZJZCwgdmFsdWUsICh2YWx1ZVJlZiAhPT0gcHJldmlvdXNWYWx1ZSkpO1xuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBkZXByZWNhdGUgcHJveGllcyBvbiBuZXh0IHZlcnNpb24uXG4gICAgICAgICAgICAgICAgLy8gZ2V0IHByb3h5IHRvIHRhcmdldCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmICh0eXBlRGVmLmdldFByb3h5KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdHlwZURlZi5nZXRQcm94eSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgaGFzQ2hhbmdlID0gKHByZXZpb3VzVmFsdWUgIT09IHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWyckY2hhbmdlcyddKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlWyckY2hhbmdlcyddLnNldFBhcmVudChcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUucmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlVHJlZS5yb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocmVmIGluc3RhbmNlb2YgU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZltmaWVsZE5hbWVdID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IHVzZSBgX2ZpZWxkYCBpbnN0ZWFkIG9mIGBmaWVsZGAuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIGBmaWVsZGAgaXMgZ29pbmcgdG8gdXNlIHRoZSBzZXR0ZXIgb2YgdGhlIFByb3BlcnR5RGVzY3JpcHRvclxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgY3JlYXRlIGEgcHJveHkgZm9yIGFycmF5L21hcC4gVGhpcyBpcyBvbmx5IHVzZWZ1bCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFja3dhcmRzLWNvbXBhdGliaWxpdHkgd2l0aCBAY29seXNldXMvc2NoZW1hQDAuNS54XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIC8vIHJlZltfZmllbGRdID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlZiBpbnN0YW5jZW9mIE1hcFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBrZXkgPSByZWZbJyRpbmRleGVzJ10uZ2V0KGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZHluYW1pY0luZGV4IGFzIHN0cmluZztcblxuICAgICAgICAgICAgICAgICAgICAvLyByZWYuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZWZbJyRpdGVtcyddLnNldChrZXksIHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVmIGluc3RhbmNlb2YgQXJyYXlTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3Qga2V5ID0gcmVmWyckaW5kZXhlcyddW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJTRVRUSU5HIEZPUiBBcnJheVNjaGVtYSA9PlwiLCB7IGZpZWxkLCBrZXksIHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyByZWZba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICByZWYuc2V0QXQoZmllbGRJbmRleCwgdmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgcmVmIGluc3RhbmNlb2YgQ29sbGVjdGlvblNjaGVtYSB8fFxuICAgICAgICAgICAgICAgICAgICByZWYgaW5zdGFuY2VvZiBTZXRTY2hlbWFcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSByZWYuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVmWydzZXRJbmRleCddKGZpZWxkSW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBoYXNDaGFuZ2VcbiAgICAgICAgICAgICAgICAvLyAmJlxuICAgICAgICAgICAgICAgIC8vIChcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5vbkNoYW5nZSB8fCByZWYuJGxpc3RlbmVyc1tmaWVsZF1cbiAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvcDogb3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBmaWVsZDogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgICAgICBkeW5hbWljSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1ZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdHJpZ2dlckNoYW5nZXMoYWxsQ2hhbmdlcyk7XG5cbiAgICAgICAgLy8gZHJvcCByZWZlcmVuY2VzIG9mIHVudXNlZCBzY2hlbWFzXG4gICAgICAgICRyb290LmdhcmJhZ2VDb2xsZWN0RGVsZXRlZFJlZnMoKTtcblxuICAgICAgICByZXR1cm4gYWxsQ2hhbmdlcztcbiAgICB9XG5cbiAgICBlbmNvZGUoXG4gICAgICAgIGVuY29kZUFsbCA9IGZhbHNlLFxuICAgICAgICBieXRlczogbnVtYmVyW10gPSBbXSxcbiAgICAgICAgdXNlRmlsdGVyczogYm9vbGVhbiA9IGZhbHNlLFxuICAgICkge1xuICAgICAgICBjb25zdCByb290Q2hhbmdlVHJlZSA9IHRoaXMuJGNoYW5nZXM7XG4gICAgICAgIGNvbnN0IHJlZklkc1Zpc2l0ZWQgPSBuZXcgV2Vha1NldDxDaGFuZ2VUcmVlPigpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5nZVRyZWVzOiBDaGFuZ2VUcmVlW10gPSBbcm9vdENoYW5nZVRyZWVdO1xuICAgICAgICBsZXQgbnVtQ2hhbmdlVHJlZXMgPSAxO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2hhbmdlVHJlZXM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IGNoYW5nZVRyZWVzW2ldO1xuICAgICAgICAgICAgY29uc3QgcmVmID0gY2hhbmdlVHJlZS5yZWY7XG4gICAgICAgICAgICBjb25zdCBpc1NjaGVtYSA9IChyZWYgaW5zdGFuY2VvZiBTY2hlbWEpO1xuXG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSB1bmlxdWUgcmVmSWQgZm9yIHRoZSBDaGFuZ2VUcmVlLlxuICAgICAgICAgICAgY2hhbmdlVHJlZS5lbnN1cmVSZWZJZCgpO1xuXG4gICAgICAgICAgICAvLyBtYXJrIHRoaXMgQ2hhbmdlVHJlZSBhcyB2aXNpdGVkLlxuICAgICAgICAgICAgcmVmSWRzVmlzaXRlZC5hZGQoY2hhbmdlVHJlZSk7XG5cbiAgICAgICAgICAgIC8vIHJvb3QgYHJlZklkYCBpcyBza2lwcGVkLlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUgIT09IHJvb3RDaGFuZ2VUcmVlICYmXG4gICAgICAgICAgICAgICAgKGNoYW5nZVRyZWUuY2hhbmdlZCB8fCBlbmNvZGVBbGwpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBlbmNvZGUudWludDgoYnl0ZXMsIFNXSVRDSF9UT19TVFJVQ1RVUkUpO1xuICAgICAgICAgICAgICAgIGVuY29kZS5udW1iZXIoYnl0ZXMsIGNoYW5nZVRyZWUucmVmSWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzOiBDaGFuZ2VPcGVyYXRpb25bXSB8IG51bWJlcltdID0gKGVuY29kZUFsbClcbiAgICAgICAgICAgICAgICA/IEFycmF5LmZyb20oY2hhbmdlVHJlZS5hbGxDaGFuZ2VzKVxuICAgICAgICAgICAgICAgIDogQXJyYXkuZnJvbShjaGFuZ2VUcmVlLmNoYW5nZXMudmFsdWVzKCkpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgY2wgPSBjaGFuZ2VzLmxlbmd0aDsgaiA8IGNsOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcGVyYXRpb246IENoYW5nZU9wZXJhdGlvbiA9IChlbmNvZGVBbGwpXG4gICAgICAgICAgICAgICAgICAgID8geyBvcDogT1BFUkFUSU9OLkFERCwgaW5kZXg6IGNoYW5nZXNbal0gYXMgbnVtYmVyIH1cbiAgICAgICAgICAgICAgICAgICAgOiBjaGFuZ2VzW2pdIGFzIENoYW5nZU9wZXJhdGlvbjtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkSW5kZXggPSBvcGVyYXRpb24uaW5kZXg7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IChpc1NjaGVtYSlcbiAgICAgICAgICAgICAgICAgICAgPyByZWZbJ19kZWZpbml0aW9uJ10uZmllbGRzQnlJbmRleCAmJiByZWZbJ19kZWZpbml0aW9uJ10uZmllbGRzQnlJbmRleFtmaWVsZEluZGV4XVxuICAgICAgICAgICAgICAgICAgICA6IGZpZWxkSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAvLyBjYWNoZSBiZWdpbiBpbmRleCBpZiBgdXNlRmlsdGVyc2BcbiAgICAgICAgICAgICAgICBjb25zdCBiZWdpbkluZGV4ID0gYnl0ZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgLy8gZW5jb2RlIGZpZWxkIGluZGV4ICsgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbi5vcCAhPT0gT1BFUkFUSU9OLlRPVUNIKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXByZXNzIGBmaWVsZEluZGV4YCArIGBvcGVyYXRpb25gIGludG8gYSBzaW5nbGUgYnl0ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgYWRkcyBhIGxpbWl0YWlvbiBvZiA2NCBmaWVsZHMgcGVyIFNjaGVtYSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGUudWludDgoYnl0ZXMsIChmaWVsZEluZGV4IHwgb3BlcmF0aW9uLm9wKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZS51aW50OChieXRlcywgb3BlcmF0aW9uLm9wKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIG9wZXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09IE9QRVJBVElPTi5DTEVBUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmRleGVkIG9wZXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZS5udW1iZXIoYnl0ZXMsIGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvLyBlbmNvZGUgXCJhbGlhc1wiIGZvciBkeW5hbWljIGZpZWxkcyAobWFwcylcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIWlzU2NoZW1hICYmXG4gICAgICAgICAgICAgICAgICAgIChvcGVyYXRpb24ub3AgJiBPUEVSQVRJT04uQUREKSA9PSBPUEVSQVRJT04uQUREIC8vIEFERCBvciBERUxFVEVfQU5EX0FERFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmIGluc3RhbmNlb2YgTWFwU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFwU2NoZW1hIGR5bmFtaWMga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHluYW1pY0luZGV4ID0gY2hhbmdlVHJlZS5yZWZbJyRpbmRleGVzJ10uZ2V0KGZpZWxkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlLnN0cmluZyhieXRlcywgZHluYW1pY0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcGVyYXRpb24ub3AgPT09IE9QRVJBVElPTi5ERUxFVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZGVsZXRlIGZyb20gZmlsdGVyIGNhY2hlIGRhdGEuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmICh1c2VGaWx0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBkZWxldGUgY2hhbmdlVHJlZS5jYWNoZXNbZmllbGRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgdHlwZSA9IGNoYW5nZVRyZWUuY2hpbGRUeXBlIHx8IHJlZi5fc2NoZW1hW2ZpZWxkXTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gY2hhbmdlVHJlZS5nZXRUeXBlKGZpZWxkSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgdHlwZSA9IGNoYW5nZVRyZWUuZ2V0VHlwZShmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGNoYW5nZVRyZWUuZ2V0VmFsdWUoZmllbGRJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAvLyBFbnF1ZXVlIENoYW5nZVRyZWUgdG8gYmUgdmlzaXRlZFxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbJyRjaGFuZ2VzJ10gJiZcbiAgICAgICAgICAgICAgICAgICAgIXJlZklkc1Zpc2l0ZWQuaGFzKHZhbHVlWyckY2hhbmdlcyddKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlcy5wdXNoKHZhbHVlWyckY2hhbmdlcyddKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbJyRjaGFuZ2VzJ10uZW5zdXJlUmVmSWQoKTtcbiAgICAgICAgICAgICAgICAgICAgbnVtQ2hhbmdlVHJlZXMrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uLm9wID09PSBPUEVSQVRJT04uVE9VQ0gpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKFNjaGVtYS5pcyh0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnRJbnN0YW5jZVR5cGUodmFsdWUsIHR5cGUgYXMgdHlwZW9mIFNjaGVtYSwgcmVmIGFzIFNjaGVtYSwgZmllbGQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIEVuY29kZSByZWZJZCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGFjdHVhbCBpbnN0YW5jZSBpcyBnb2luZyB0byBiZSBlbmNvZGVkIG9uIG5leHQgYGNoYW5nZVRyZWVgIGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgZW5jb2RlLm51bWJlcihieXRlcywgdmFsdWUuJGNoYW5nZXMucmVmSWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBlbmNvZGUgaW5oZXJpdGVkIFRZUEVfSUQgaWYgaXQncyBhbiBBREQgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICBpZiAoKG9wZXJhdGlvbi5vcCAmIE9QRVJBVElPTi5BREQpID09PSBPUEVSQVRJT04uQUREKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeUVuY29kZVR5cGVJZChieXRlcywgdHlwZSBhcyB0eXBlb2YgU2NoZW1hLCB2YWx1ZS5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgU2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YodHlwZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJpbWl0aXZlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGVQcmltaXRpdmVUeXBlKHR5cGUgYXMgUHJpbWl0aXZlVHlwZSwgYnl0ZXMsIHZhbHVlLCByZWYgYXMgU2NoZW1hLCBmaWVsZCk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBDdXN0b20gdHlwZSAoTWFwU2NoZW1hLCBBcnJheVNjaGVtYSwgZXRjKVxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gZ2V0VHlwZShPYmplY3Qua2V5cyh0eXBlKVswXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gZW5zdXJlIGEgQXJyYXlTY2hlbWEgaGFzIGJlZW4gcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0SW5zdGFuY2VUeXBlKHJlZltgXyR7ZmllbGR9YF0sIGRlZmluaXRpb24uY29uc3RydWN0b3IsIHJlZiBhcyBTY2hlbWEsIGZpZWxkKTtcblxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBFbmNvZGUgcmVmSWQgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBhY3R1YWwgaW5zdGFuY2UgaXMgZ29pbmcgdG8gYmUgZW5jb2RlZCBvbiBuZXh0IGBjaGFuZ2VUcmVlYCBpdGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZS5udW1iZXIoYnl0ZXMsIHZhbHVlLiRjaGFuZ2VzLnJlZklkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodXNlRmlsdGVycykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZSBiZWdpbiAvIGVuZCBpbmRleFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlLmNhY2hlKGZpZWxkSW5kZXggYXMgbnVtYmVyLCBieXRlcy5zbGljZShiZWdpbkluZGV4KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWVuY29kZUFsbCAmJiAhdXNlRmlsdGVycykge1xuICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUuZGlzY2FyZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cblxuICAgIGVuY29kZUFsbCAodXNlRmlsdGVycz86IGJvb2xlYW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlKHRydWUsIFtdLCB1c2VGaWx0ZXJzKTtcbiAgICB9XG5cbiAgICBhcHBseUZpbHRlcnMoY2xpZW50OiBDbGllbnQsIGVuY29kZUFsbDogYm9vbGVhbiA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzO1xuICAgICAgICBjb25zdCByZWZJZHNEaXNzYWxsb3dlZCA9IG5ldyBTZXQ8bnVtYmVyPigpO1xuXG4gICAgICAgIGNvbnN0ICRmaWx0ZXJTdGF0ZSA9IENsaWVudFN0YXRlLmdldChjbGllbnQpO1xuXG4gICAgICAgIGNvbnN0IGNoYW5nZVRyZWVzID0gW3RoaXMuJGNoYW5nZXNdO1xuICAgICAgICBsZXQgbnVtQ2hhbmdlVHJlZXMgPSAxO1xuXG4gICAgICAgIGxldCBmaWx0ZXJlZEJ5dGVzOiBudW1iZXJbXSA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2hhbmdlVHJlZXM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlVHJlZSA9IGNoYW5nZVRyZWVzW2ldO1xuXG4gICAgICAgICAgICBpZiAocmVmSWRzRGlzc2FsbG93ZWQuaGFzKGNoYW5nZVRyZWUucmVmSWQpKSAge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiUkVGSUQgSVMgTk9UIEFMTE9XRUQuIFNLSVAuXCIsIHsgcmVmSWQ6IGNoYW5nZVRyZWUucmVmSWQgfSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmVmID0gY2hhbmdlVHJlZS5yZWYgYXMgUmVmO1xuICAgICAgICAgICAgY29uc3QgaXNTY2hlbWE6IGJvb2xlYW4gPSByZWYgaW5zdGFuY2VvZiBTY2hlbWE7XG5cbiAgICAgICAgICAgIGVuY29kZS51aW50OChmaWx0ZXJlZEJ5dGVzLCBTV0lUQ0hfVE9fU1RSVUNUVVJFKTtcbiAgICAgICAgICAgIGVuY29kZS5udW1iZXIoZmlsdGVyZWRCeXRlcywgY2hhbmdlVHJlZS5yZWZJZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNsaWVudEhhc1JlZklkID0gJGZpbHRlclN0YXRlLnJlZklkcy5oYXMoY2hhbmdlVHJlZSk7XG4gICAgICAgICAgICBjb25zdCBpc0VuY29kZUFsbCA9IChlbmNvZGVBbGwgfHwgIWNsaWVudEhhc1JlZklkKTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJSRUY6XCIsIHJlZi5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRW5jb2RlIGFsbD9cIiwgaXNFbmNvZGVBbGwpO1xuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gaW5jbHVkZSBgY2hhbmdlVHJlZWAgb24gbGlzdCBvZiBrbm93biByZWZJZHMgYnkgdGhpcyBjbGllbnQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgJGZpbHRlclN0YXRlLmFkZFJlZklkKGNoYW5nZVRyZWUpO1xuXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJJbmRleGVzID0gJGZpbHRlclN0YXRlLmNvbnRhaW5lckluZGV4ZXMuZ2V0KGNoYW5nZVRyZWUpXG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gKGlzRW5jb2RlQWxsKVxuICAgICAgICAgICAgICAgID8gQXJyYXkuZnJvbShjaGFuZ2VUcmVlLmFsbENoYW5nZXMpXG4gICAgICAgICAgICAgICAgOiBBcnJheS5mcm9tKGNoYW5nZVRyZWUuY2hhbmdlcy52YWx1ZXMoKSk7XG5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBXT1JLQVJPVU5EOiB0cmllcyB0byByZS1ldmFsdWF0ZSBwcmV2aW91c2x5IG5vdCBpbmNsdWRlZCBAZmlsdGVyKCkgYXR0cmlidXRlc1xuICAgICAgICAgICAgLy8gLSBzZWUgXCJERUxFVEUgYSBmaWVsZCBvZiBTY2hlbWFcIiB0ZXN0IGNhc2UuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICFlbmNvZGVBbGwgJiZcbiAgICAgICAgICAgICAgICBpc1NjaGVtYSAmJlxuICAgICAgICAgICAgICAgIChyZWYgYXMgU2NoZW1hKS5fZGVmaW5pdGlvbi5pbmRleGVzV2l0aEZpbHRlcnNcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ZXNXaXRoRmlsdGVycyA9IChyZWYgYXMgU2NoZW1hKS5fZGVmaW5pdGlvbi5pbmRleGVzV2l0aEZpbHRlcnM7XG4gICAgICAgICAgICAgICAgaW5kZXhlc1dpdGhGaWx0ZXJzLmZvckVhY2goaW5kZXhXaXRoRmlsdGVyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgIWNvbnRhaW5lckluZGV4ZXMuaGFzKGluZGV4V2l0aEZpbHRlcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZVRyZWUuYWxsQ2hhbmdlcy5oYXMoaW5kZXhXaXRoRmlsdGVyKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VuY29kZUFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaChpbmRleFdpdGhGaWx0ZXIgYXMgYW55KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBvcDogT1BFUkFUSU9OLkFERCwgaW5kZXg6IGluZGV4V2l0aEZpbHRlciwgfSBhcyBhbnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBjbCA9IGNoYW5nZXMubGVuZ3RoOyBqIDwgY2w7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZTogQ2hhbmdlT3BlcmF0aW9uID0gKGlzRW5jb2RlQWxsKVxuICAgICAgICAgICAgICAgICAgICA/IHsgb3A6IE9QRVJBVElPTi5BREQsIGluZGV4OiBjaGFuZ2VzW2pdIGFzIG51bWJlciB9XG4gICAgICAgICAgICAgICAgICAgIDogY2hhbmdlc1tqXSBhcyBDaGFuZ2VPcGVyYXRpb247XG5cbiAgICAgICAgICAgICAgICAvLyBjdXN0b20gb3BlcmF0aW9uc1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uub3AgPT09IE9QRVJBVElPTi5DTEVBUikge1xuICAgICAgICAgICAgICAgICAgICBlbmNvZGUudWludDgoZmlsdGVyZWRCeXRlcywgY2hhbmdlLm9wKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRJbmRleCA9IGNoYW5nZS5pbmRleDtcblxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gRGVsZXRpbmcgZmllbGRzOiBlbmNvZGUgdGhlIG9wZXJhdGlvbiArIGZpZWxkIGluZGV4XG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLm9wID09PSBPUEVSQVRJT04uREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIC8vIERFTEVURSBvcGVyYXRpb25zIGFsc28gbmVlZCB0byBnbyB0aHJvdWdoIGZpbHRlcmluZy5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogY2FjaGUgdGhlIHByZXZpb3VzIHZhbHVlIHNvIHdlIGNhbiBhY2Nlc3MgdGhlIHZhbHVlIChwcmltaXRpdmUgb3IgYHJlZklkYClcbiAgICAgICAgICAgICAgICAgICAgLy8gKGNoZWNrIGFnYWluc3QgYCRmaWx0ZXJTdGF0ZS5yZWZJZHNgKVxuICAgICAgICAgICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlLnVpbnQ4KGZpbHRlcmVkQnl0ZXMsIGNoYW5nZS5vcCB8IGZpZWxkSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGUudWludDgoZmlsdGVyZWRCeXRlcywgY2hhbmdlLm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZS5udW1iZXIoZmlsdGVyZWRCeXRlcywgZmllbGRJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpbmRleGVkIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2hhbmdlVHJlZS5nZXRWYWx1ZShmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gY2hhbmdlVHJlZS5nZXRUeXBlKGZpZWxkSW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElzIGEgU2NoZW1hIVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSAoXG4gICAgICAgICAgICAgICAgICAgICAgICAocmVmIGFzIFNjaGVtYSkuX2RlZmluaXRpb24uZmlsdGVycyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlZiBhcyBTY2hlbWEpLl9kZWZpbml0aW9uLmZpbHRlcnNbZmllbGRJbmRleF1cbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXIuY2FsbChyZWYsIGNsaWVudCwgdmFsdWUsIHJvb3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWVbJyRjaGFuZ2VzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZJZHNEaXNzYWxsb3dlZC5hZGQodmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWQpOztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJcyBhIGNvbGxlY3Rpb24hIChtYXAsIGFycmF5LCBldGMuKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBjaGFuZ2VUcmVlLnBhcmVudCBhcyBSZWY7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IGNoYW5nZVRyZWUuZ2V0Q2hpbGRyZW5GaWx0ZXIoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXIuY2FsbChwYXJlbnQsIGNsaWVudCwgcmVmWyckaW5kZXhlcyddLmdldChmaWVsZEluZGV4KSwgdmFsdWUsIHJvb3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgdmFsdWVbJyRjaGFuZ2VzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZJZHNEaXNzYWxsb3dlZC5hZGQodmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyB2aXNpdCBjaGlsZCBDaGFuZ2VUcmVlIG9uIGZ1cnRoZXIgaXRlcmF0aW9uLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsnJGNoYW5nZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VUcmVlcy5wdXNoKHZhbHVlWyckY2hhbmdlcyddKTtcbiAgICAgICAgICAgICAgICAgICAgbnVtQ2hhbmdlVHJlZXMrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIENvcHkgY2FjaGVkIGJ5dGVzXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLm9wICE9PSBPUEVSQVRJT04uVE9VQ0gpIHtcblxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByZWZhY3RvciBtZSFcbiAgICAgICAgICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLm9wID09PSBPUEVSQVRJT04uQUREIHx8IGlzU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGNhY2hlZCBieXRlcyBkaXJlY3RseSBpZiBpcyBmcm9tIFNjaGVtYSB0eXBlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkQnl0ZXMgPSBmaWx0ZXJlZEJ5dGVzLmNvbmNhdChjaGFuZ2VUcmVlLmNhY2hlc1tmaWVsZEluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXJJbmRleGVzLmFkZChmaWVsZEluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lckluZGV4ZXMuaGFzKGZpZWxkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgY2FjaGVkIGJ5dGVzIGlmIGFscmVhZHkgaGFzIHRoZSBmaWVsZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRCeXRlcyA9IGZpbHRlcmVkQnl0ZXMuY29uY2F0KGNoYW5nZVRyZWUuY2FjaGVzW2ZpZWxkSW5kZXhdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIEFERCBvcGVyYXRpb24gaWYgZmllbGQgaXMgbm90IGtub3duIGJ5IHRoaXMgY2xpZW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVySW5kZXhlcy5hZGQoZmllbGRJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGUudWludDgoZmlsdGVyZWRCeXRlcywgT1BFUkFUSU9OLkFERCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlLm51bWJlcihmaWx0ZXJlZEJ5dGVzLCBmaWVsZEluZGV4KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiBNYXBTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFwU2NoZW1hIGR5bmFtaWMga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNJbmRleCA9IGNoYW5nZVRyZWUucmVmWyckaW5kZXhlcyddLmdldChmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5jb2RlLnN0cmluZyhmaWx0ZXJlZEJ5dGVzLCBkeW5hbWljSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsnJGNoYW5nZXMnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmNvZGUubnVtYmVyKGZpbHRlcmVkQnl0ZXMsIHZhbHVlWyckY2hhbmdlcyddLnJlZklkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiZW5jb2RlUHJpbWl0aXZlVHlwZVwiIHdpdGhvdXQgdHlwZSBjaGVja2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHR5cGUgY2hlY2tpbmcgaGFzIGJlZW4gZG9uZSBvbiB0aGUgZmlyc3QgLmVuY29kZSgpIGNhbGwuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVt0eXBlIGFzIHN0cmluZ10oZmlsdGVyZWRCeXRlcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZVsnJGNoYW5nZXMnXSAmJiAhaXNTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgICAgICAgICAgICAgLy8gLSB0cmFjayBBREQvUkVQTEFDRS9ERUxFVEUgaW5zdGFuY2VzIG9uIGAkZmlsdGVyU3RhdGVgXG4gICAgICAgICAgICAgICAgICAgIC8vIC0gZG8gTk9UIGFsd2F5cyBlbmNvZGUgZHluYW1pY0luZGV4IGZvciBNYXBTY2hlbWEuXG4gICAgICAgICAgICAgICAgICAgIC8vICAgKElmIGNsaWVudCBhbHJlYWR5IGhhcyB0aGF0IGtleSwgb25seSB0aGUgZmlyc3QgaW5kZXggaXMgbmVjZXNzYXJ5LilcbiAgICAgICAgICAgICAgICAgICAgLy9cblxuICAgICAgICAgICAgICAgICAgICBlbmNvZGUudWludDgoZmlsdGVyZWRCeXRlcywgT1BFUkFUSU9OLkFERCk7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kZS5udW1iZXIoZmlsdGVyZWRCeXRlcywgZmllbGRJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIE1hcFNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hcFNjaGVtYSBkeW5hbWljIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNJbmRleCA9IGNoYW5nZVRyZWUucmVmWyckaW5kZXhlcyddLmdldChmaWVsZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZS5zdHJpbmcoZmlsdGVyZWRCeXRlcywgZHluYW1pY0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGVuY29kZS5udW1iZXIoZmlsdGVyZWRCeXRlcywgdmFsdWVbJyRjaGFuZ2VzJ10ucmVmSWQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmaWx0ZXJlZEJ5dGVzO1xuICAgIH1cblxuICAgIGNsb25lICgpOiB0aGlzIHtcbiAgICAgICAgY29uc3QgY2xvbmVkID0gbmV3ICgodGhpcyBhcyBhbnkpLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5fZGVmaW5pdGlvbi5zY2hlbWE7XG4gICAgICAgIGZvciAobGV0IGZpZWxkIGluIHNjaGVtYSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHR5cGVvZiAodGhpc1tmaWVsZF0pID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mICh0aGlzW2ZpZWxkXS5jbG9uZSkgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVlcCBjbG9uZVxuICAgICAgICAgICAgICAgIGNsb25lZFtmaWVsZF0gPSB0aGlzW2ZpZWxkXS5jbG9uZSgpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHByaW1pdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgICAgICBjbG9uZWRbZmllbGRdID0gdGhpc1tmaWVsZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG5cbiAgICB0cmlnZ2VyQWxsKCkge1xuICAgICAgICAvLyBza2lwIGlmIGhhdmVuJ3QgcmVjZWl2ZWQgYW55IHJlbW90ZSByZWZzIHlldC5cbiAgICAgICAgaWYgKHRoaXMuJGNoYW5nZXMucm9vdC5yZWZzLnNpemUgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgY29uc3QgYWxsQ2hhbmdlcyA9IG5ldyBNYXA8bnVtYmVyLCBEYXRhQ2hhbmdlW10+KCk7XG4gICAgICAgIFNjaGVtYS5wcm90b3R5cGUuX3RyaWdnZXJBbGxGaWxsQ2hhbmdlcy5jYWxsKHRoaXMsIHRoaXMsIGFsbENoYW5nZXMpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBTY2hlbWEucHJvdG90eXBlLl90cmlnZ2VyQ2hhbmdlcy5jYWxsKHRoaXMsIGFsbENoYW5nZXMpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIFNjaGVtYS5vbkVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9KU09OICgpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5fZGVmaW5pdGlvbi5zY2hlbWE7XG4gICAgICAgIGNvbnN0IGRlcHJlY2F0ZWQgPSB0aGlzLl9kZWZpbml0aW9uLmRlcHJlY2F0ZWQ7XG5cbiAgICAgICAgY29uc3Qgb2JqID0ge31cbiAgICAgICAgZm9yIChsZXQgZmllbGQgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICBpZiAoIWRlcHJlY2F0ZWRbZmllbGRdICYmIHRoaXNbZmllbGRdICE9PSBudWxsICYmIHR5cGVvZiAodGhpc1tmaWVsZF0pICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgb2JqW2ZpZWxkXSA9ICh0eXBlb2YgKHRoaXNbZmllbGRdWyd0b0pTT04nXSkgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzW2ZpZWxkXVsndG9KU09OJ10oKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXNbYF8ke2ZpZWxkfWBdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgZGlzY2FyZEFsbENoYW5nZXMoKSB7XG4gICAgICAgIHRoaXMuJGNoYW5nZXMuZGlzY2FyZEFsbCgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRCeUluZGV4KGluZGV4OiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGhpcy5fZGVmaW5pdGlvbi5maWVsZHNCeUluZGV4W2luZGV4XV07XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGRlbGV0ZUJ5SW5kZXgoaW5kZXg6IG51bWJlcikge1xuICAgICAgICB0aGlzW3RoaXMuX2RlZmluaXRpb24uZmllbGRzQnlJbmRleFtpbmRleF1dID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHByaXZhdGUgdHJ5RW5jb2RlVHlwZUlkIChieXRlczogbnVtYmVyW10sIHR5cGU6IHR5cGVvZiBTY2hlbWEsIHRhcmdldFR5cGU6IHR5cGVvZiBTY2hlbWEpIHtcbiAgICAgICAgaWYgKHR5cGUuX3R5cGVpZCAhPT0gdGFyZ2V0VHlwZS5fdHlwZWlkKSB7XG4gICAgICAgICAgICBlbmNvZGUudWludDgoYnl0ZXMsIFRZUEVfSUQpO1xuICAgICAgICAgICAgZW5jb2RlLm51bWJlcihieXRlcywgdGFyZ2V0VHlwZS5fdHlwZWlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0U2NoZW1hVHlwZShieXRlczogbnVtYmVyW10sIGl0OiBkZWNvZGUuSXRlcmF0b3IsIGRlZmF1bHRUeXBlOiB0eXBlb2YgU2NoZW1hKTogdHlwZW9mIFNjaGVtYSB7XG4gICAgICAgIGxldCB0eXBlOiB0eXBlb2YgU2NoZW1hO1xuXG4gICAgICAgIGlmIChieXRlc1tpdC5vZmZzZXRdID09PSBUWVBFX0lEKSB7XG4gICAgICAgICAgICBpdC5vZmZzZXQrKztcbiAgICAgICAgICAgIHR5cGUgPSAodGhpcy5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgU2NoZW1hKS5fY29udGV4dC5nZXQoZGVjb2RlLm51bWJlcihieXRlcywgaXQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eXBlIHx8IGRlZmF1bHRUeXBlO1xuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlVHlwZUluc3RhbmNlICh0eXBlOiB0eXBlb2YgU2NoZW1hKTogU2NoZW1hIHtcbiAgICAgICAgbGV0IGluc3RhbmNlOiBTY2hlbWEgPSBuZXcgKHR5cGUgYXMgYW55KSgpO1xuXG4gICAgICAgIC8vIGFzc2lnbiByb290IG9uICRjaGFuZ2VzXG4gICAgICAgIGluc3RhbmNlLiRjaGFuZ2VzLnJvb3QgPSB0aGlzLiRjaGFuZ2VzLnJvb3Q7XG5cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3RyaWdnZXJBbGxGaWxsQ2hhbmdlcyhyZWY6IFJlZiwgYWxsQ2hhbmdlczogTWFwPG51bWJlciwgRGF0YUNoYW5nZVtdPikge1xuICAgICAgICBpZiAoYWxsQ2hhbmdlcy5oYXMocmVmWyckY2hhbmdlcyddLnJlZklkKSkgeyByZXR1cm47IH1cblxuICAgICAgICBjb25zdCBjaGFuZ2VzOiBEYXRhQ2hhbmdlW10gPSBbXTtcbiAgICAgICAgYWxsQ2hhbmdlcy5zZXQocmVmWyckY2hhbmdlcyddLnJlZklkIHx8IDAsIGNoYW5nZXMpO1xuXG4gICAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiBTY2hlbWEpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHJlZi5fZGVmaW5pdGlvbi5zY2hlbWE7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGZpZWxkTmFtZSBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfZmllbGQgPSBgXyR7ZmllbGROYW1lfWA7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZWZbX2ZpZWxkXTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcDogT1BFUkFUSU9OLkFERCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVbJyRjaGFuZ2VzJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgU2NoZW1hLnByb3RvdHlwZS5fdHJpZ2dlckFsbEZpbGxDaGFuZ2VzLmNhbGwodGhpcywgdmFsdWUsIGFsbENoYW5nZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJpZXM6IEl0ZXJhYmxlSXRlcmF0b3I8W2FueSwgYW55XT4gID0gcmVmLmVudHJpZXMoKTtcbiAgICAgICAgICAgIGxldCBpdGVyOiBJdGVyYXRvclJlc3VsdDxbYW55LCBhbnldPjtcblxuICAgICAgICAgICAgd2hpbGUgKChpdGVyID0gZW50cmllcy5uZXh0KCkpICYmICFpdGVyLmRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBpdGVyLnZhbHVlO1xuXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgb3A6IE9QRVJBVElPTi5BREQsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBrZXksXG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNJbmRleDoga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVsnJGNoYW5nZXMnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIFNjaGVtYS5wcm90b3R5cGUuX3RyaWdnZXJBbGxGaWxsQ2hhbmdlcy5jYWxsKHRoaXMsIHZhbHVlLCBhbGxDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF90cmlnZ2VyQ2hhbmdlcyhhbGxDaGFuZ2VzOiBNYXA8bnVtYmVyLCBEYXRhQ2hhbmdlW10+KSB7XG4gICAgICAgIGFsbENoYW5nZXMuZm9yRWFjaCgoY2hhbmdlcywgcmVmSWQpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWYgPSB0aGlzLiRjaGFuZ2VzLnJvb3QucmVmcy5nZXQocmVmSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzU2NoZW1hID0gcmVmIGluc3RhbmNlb2YgU2NoZW1hO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gcmVmWyckbGlzdGVuZXJzJ10gJiYgcmVmWyckbGlzdGVuZXJzJ11bY2hhbmdlLmZpZWxkXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLm9wID09PSBPUEVSQVRJT04uQUREICYmIGNoYW5nZS5wcmV2aW91c1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVmIGFzIFNjaGVtYURlY29kZXJDYWxsYmFja3MpLm9uQWRkPy4oY2hhbmdlLnZhbHVlLCBjaGFuZ2UuZHluYW1pY0luZGV4ID8/IGNoYW5nZS5maWVsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhbmdlLm9wID09PSBPUEVSQVRJT04uREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogYHByZXZpb3VzVmFsdWVgIHNob3VsZCBhbHdheXMgYmUgYXZhaWlhYmxlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFERCArIERFTEVURSBvcGVyYXRpb25zIGFyZSBzdGlsbCBlbmNvZGluZyBERUxFVEUgb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5wcmV2aW91c1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlZiBhcyBTY2hlbWFEZWNvZGVyQ2FsbGJhY2tzKS5vblJlbW92ZT8uKGNoYW5nZS5wcmV2aW91c1ZhbHVlLCBjaGFuZ2UuZHluYW1pY0luZGV4ID8/IGNoYW5nZS5maWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYW5nZS5vcCA9PT0gT1BFUkFUSU9OLkRFTEVURV9BTkRfQUREKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5wcmV2aW91c1ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlZiBhcyBTY2hlbWFEZWNvZGVyQ2FsbGJhY2tzKS5vblJlbW92ZT8uKGNoYW5nZS5wcmV2aW91c1ZhbHVlLCBjaGFuZ2UuZHluYW1pY0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlZiBhcyBTY2hlbWFEZWNvZGVyQ2FsbGJhY2tzKS5vbkFkZD8uKGNoYW5nZS52YWx1ZSwgY2hhbmdlLmR5bmFtaWNJbmRleCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLm9wID09PSBPUEVSQVRJT04uUkVQTEFDRSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS52YWx1ZSAhPT0gY2hhbmdlLnByZXZpb3VzVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZWYgYXMgU2NoZW1hRGVjb2RlckNhbGxiYWNrcykub25DaGFuZ2U/LihjaGFuZ2UudmFsdWUsIGNoYW5nZS5keW5hbWljSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlciBvblJlbW92ZSBvbiBjaGlsZCBzdHJ1Y3R1cmUuXG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIChjaGFuZ2Uub3AgJiBPUEVSQVRJT04uREVMRVRFKSA9PT0gT1BFUkFUSU9OLkRFTEVURSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLnByZXZpb3VzVmFsdWUgaW5zdGFuY2VvZiBTY2hlbWEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5wcmV2aW91c1ZhbHVlLm9uUmVtb3ZlXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlLnByZXZpb3VzVmFsdWUub25SZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5pbnZva2UoY2hhbmdlLnZhbHVlLCBjaGFuZ2UucHJldmlvdXNWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2NoZW1hLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlZi5vbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVmIGFzIFNjaGVtYSkub25DaGFuZ2UoY2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2NoZW1hLm9uRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICB9XG59XG4iXX0=