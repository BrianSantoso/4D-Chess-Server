import { Connection } from './Connection';
import { Serializer } from './serializer/Serializer';
import { Listener } from '@gamestdio/state-listener';
import { SchemaConstructor } from './serializer/SchemaSerializer';
import { Schema } from '@colyseus/schema';
export interface RoomAvailable<Metadata = any> {
    roomId: string;
    clients: number;
    maxClients: number;
    metadata?: Metadata;
}
export declare class Room<State = any> {
    id: string;
    sessionId: string;
    name: string;
    connection: Connection;
    onStateChange: {
        (this: any, cb: (state: State) => void): import("strong-events/lib").EventEmitter<(state: State) => void>;
        once(cb: (state: State) => void): void;
        remove(cb: (state: State) => void): void;
        invoke(state: State): void;
        invokeAsync(state: State): Promise<any[]>;
        clear(): void;
    };
    onError: {
        (this: any, cb: (code: number, message?: string) => void): import("strong-events/lib").EventEmitter<(code: number, message?: string) => void>;
        once(cb: (code: number, message?: string) => void): void;
        remove(cb: (code: number, message?: string) => void): void;
        invoke(code: number, message?: string): void;
        invokeAsync(code: number, message?: string): Promise<any[]>;
        clear(): void;
    };
    onLeave: {
        (this: any, cb: (code: number) => void): import("strong-events/lib").EventEmitter<(code: number) => void>;
        once(cb: (code: number) => void): void;
        remove(cb: (code: number) => void): void;
        invoke(code: number): void;
        invokeAsync(code: number): Promise<any[]>;
        clear(): void;
    };
    protected onJoin: {
        (this: any, cb: (...args: any[]) => void | Promise<any>): import("strong-events/lib").EventEmitter<(...args: any[]) => void | Promise<any>>;
        once(cb: (...args: any[]) => void | Promise<any>): void;
        remove(cb: (...args: any[]) => void | Promise<any>): void;
        invoke(...args: any[]): void;
        invokeAsync(...args: any[]): Promise<any[]>;
        clear(): void;
    };
    serializerId: string;
    protected serializer: Serializer<State>;
    protected hasJoined: boolean;
    protected rootSchema: SchemaConstructor<State>;
    protected onMessageHandlers: import("nanoevents").Emitter<import("nanoevents").DefaultEvents>;
    constructor(name: string, rootSchema?: SchemaConstructor<State>);
    connect(endpoint: string): void;
    leave(consented?: boolean): void;
    onMessage<T = any>(type: "*", callback: (type: string | number | Schema, message: T) => void): any;
    onMessage<T extends (typeof Schema & (new (...args: any[]) => any))>(type: T, callback: (message: InstanceType<T>) => void): any;
    onMessage<T = any>(type: string | number, callback: (message: T) => void): any;
    send(type: string | number, message?: any): void;
    get state(): State;
    listen(segments: string, callback: Function, immediate?: boolean): Listener;
    removeListener(listener: Listener): void;
    removeAllListeners(): void;
    protected onMessageCallback(event: MessageEvent): void;
    protected setState(encodedState: number[]): void;
    protected patch(binaryPatch: number[]): void;
    private dispatchMessage;
    private destroy;
    private getMessageHandlerKey;
}
